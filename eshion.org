* Base
** Load path etc.
#+BEGIN_SRC emacs-lisp
(let ((elisp-dir (expand-file-name "src" emacs-base-dir)))
  ;; add the src directory to the load path
  (add-to-list 'load-path elisp-dir)
  ;; load specific files
  (when (file-exists-p elisp-dir)
    (let ((default-directory elisp-dir))
      (normal-top-level-add-subdirs-to-load-path))))
(setq autoload-file (concat emacs-base-dir "loaddefs.el"))
(setq package-user-dir (concat emacs-base-dir "elpa"))
(setq custom-file (concat emacs-base-dir "custom.el"))
#+END_SRC
** Backups
#+BEGIN_SRC emacs-lisp
(setq backup-directory-alist
      `((".*" . ,temporary-file-directory)))
(setq auto-save-file-name-transforms
      `((".*" ,temporary-file-directory t)))

;;varsion control
(setq version-control 1)
(setq kept-old-versions 2)
(setq kept-new-versions 5)
(setq delete-old-versions t)
(setq backup-directory-alist '(("." . "~/var/tmp")))
(setq make-backup-files nil)
(setq backup-by-copying t)
#+END_SRC
** History
#+BEGIN_SRC emacs-lisp
(require 'recentf)
(recentf-mode 1)
#+END_SRC
* Helper functions
#+BEGIN_SRC emacs-lisp
(defun kill-default-buffer ()
  "Kill the currently active buffer -- set to C-x k so that users are not asked which buffer they want to kill."
  (interactive)
  (let (kill-buffer-query-functions) (kill-buffer)))

(defun kill-buffer-if-file (buf)
  "Kill a buffer only if it is file-based."
  (when (buffer-file-name buf)
    (when (buffer-modified-p buf)
        (when (y-or-n-p (format "Buffer %s is modified - save it?" (buffer-name buf)))
            (save-some-buffers nil buf)))
    (set-buffer-modified-p nil)
    (kill-buffer buf)))

(defun kill-all-buffers ()
    "Kill all file-based buffers."
    (interactive)
    (mapc (lambda (buf) (kill-buffer-if-file buf))
     (buffer-list)))

(defun kill-buffer-and-window ()
  "Close the current window and kill the buffer it's visiting."
  (interactive)
  (progn
    (kill-buffer)
    (delete-window)))

(defun create-new-buffer ()
  "Create a new buffer named *new*[num]."
  (interactive)
  (switch-to-buffer (generate-new-buffer-name "*new*")))

(defun insert-semicolon-at-end-of-line ()
  "Add a closing semicolon from anywhere in the line."
  (interactive)
  (save-excursion
    (end-of-line)
    (insert ";")))

(defun comment-current-line-dwim ()
  "Comment or uncomment the current line."
  (interactive)
  (save-excursion
    (push-mark (beginning-of-line) t t)
    (end-of-line)
    (comment-dwim nil)))

(defun newline-anywhere ()
  "Add a newline from anywhere in the line."
  (interactive)
  (end-of-line)
  (newline-and-indent))

(defun increase-window-height (&optional arg)
  "Make the window taller by one line. Useful when bound to a repeatable key combination."
  (interactive "p")
  (enlarge-window arg))

(defun decrease-window-height (&optional arg)
  "Make the window shorter by one line. Useful when bound to a repeatable key combination."
  (interactive "p")
  (enlarge-window (- 0 arg)))

(defun decrease-window-width (&optional arg)
  "Make the window narrower by one column. Useful when bound to a repeatable key combination."
  (interactive "p")
  (enlarge-window (- 0 arg) t))

(defun increase-window-width (&optional arg)
  "Make the window wider by one column. Useful when bound to a repeatable key combination."
  (interactive "p")
  (enlarge-window arg t))

;; Create a new instance of emacs
(when window-system
  (defun new-emacs-instance ()
    (interactive)
    (let ((path-to-emacs
           (locate-file invocation-name
                        (list invocation-directory) exec-suffixes)))
      (call-process path-to-emacs nil 0 nil))))
#+END_SRC
* Editing
#+BEGIN_SRC emacs-lisp
  ;; Delete marked text on typing
  (delete-selection-mode t)
  ;; Don't use tabs for indent; replace tabs with two spaces.
  (setq-default tab-width 2)
  (setq-default indent-tabs-mode nil)
  (setq-default js-indent-level 2)
  ;; newline-and-indent
  (global-set-key (kbd "RET") 'newline-and-indent)
  ;; Show matching parens
  (show-paren-mode 1)
  ;; yes/no to y/n
  (fset 'yes-or-no-p 'y-or-n-p)
  ;; max kill-ring
  (setq kill-ring-max 200)
#+END_SRC
** Switching Next/Previous User Buffers
#+BEGIN_SRC emacs-lisp
(defun next-user-buffer ()
  "Switch to the next user buffer.
User buffers are those whose name does not start with *."
  (interactive)
  (next-buffer)
  (let ((i 0))
    (while (and (string-match "^*" (buffer-name)) (< i 50))
      (setq i (1+ i)) (next-buffer) )))

(defun previous-user-buffer ()
  "Switch to the previous user buffer.
User buffers are those whose name does not start with *."
  (interactive)
  (previous-buffer)
  (let ((i 0))
    (while (and (string-match "^*" (buffer-name)) (< i 50))
      (setq i (1+ i)) (previous-buffer) )))

(defun next-emacs-buffer ()
  "Switch to the next emacs buffer.
Emacs buffers are those whose name starts with *."
  (interactive)
  (next-buffer)
  (let ((i 0))
    (while (and (not (string-match "^*" (buffer-name))) (< i 50))
      (setq i (1+ i)) (next-buffer) )))

(defun previous-emacs-buffer ()
  "Switch to the previous emacs buffer.
Emacs buffers are those whose name starts with *."
  (interactive)
  (previous-buffer)
  (let ((i 0))
    (while (and (not (string-match "^*" (buffer-name))) (< i 50))
      (setq i (1+ i)) (previous-buffer) )))

(global-set-key (kbd "<f5>") 'previous-user-buffer)
(global-set-key (kbd "<f6>") 'next-user-buffer)
(global-set-key (kbd "<C-f5>") 'previous-emacs-buffer)
(global-set-key (kbd "<C-f6>") 'next-emacs-buffer)
#+END_SRC
** hippie-expand
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "M-/") 'hippie-expand)

(setq hippie-expand-try-functions-list
      '(try-complete-file-name-partially
        try-complete-file-name
        try-expand-dabbrev
        try-expand-dabbrev-all-buffers
        try-expand-dabbrev-from-kill))
#+END_SRC
** Mouse wheel scroll
#+BEGIN_SRC emacs-lisp
(setq mouse-wheel-scroll-amount '(1 ((shift) . 1)((control)))
mouse-wheel-progressive-speed nil
scroll-step 1)
#+END_SRC
** make-buffer-file-executable
#+BEGIN_SRC emacs-lisp
(add-hook 'after-save-hook 'executable-make-buffer-file-executable-if-script-p)
#+END_SRC
* Mac
#+BEGIN_SRC emacs-lisp
  (when (memq window-system '(mac ns))
    (progn
      (use-package exec-path-from-shell
        :ensure t
        :config
        (progn 
          (exec-path-from-shell-initialize)
          ))
      ))
#+END_SRC
* GUI
** Window size and features
#+BEGIN_SRC emacs-lisp
  (when window-system
  ;(tooltip-mode -1)
    (tool-bar-mode -1)
    (menu-bar-mode -1)
    (scroll-bar-mode -1))

  (setq frame-title-format
        '((:eval (if (buffer-file-name)
                     (abbreviate-file-name (buffer-file-name))
                   "%b"))))
  (setq-default cursor-type 'bar)
  (setq visible-bell t
        echo-keystrokes 0.1
        ;blink-cursor-mode nil
        inhibit-startup-message t
        inhibit-startup-echo-area-message t
        ring-bell-function 'ignore
        transient-mark-mode t)
  ;(global-hl-line-mode 1)
#+END_SRC
** adjust-opacity
#+BEGIN_SRC emacs-lisp
(defun adjust-opacity (frame incr)
  (let* ((oldalpha (or (frame-parameter frame 'alpha) 100))
         (newalpha (+ incr oldalpha)))
    (when (and (<= frame-alpha-lower-limit newalpha) (>= 100 newalpha))
      (modify-frame-parameters frame (list (cons 'alpha newalpha))))))
(global-set-key (kbd "M-C-8") '(lambda () (interactive) (adjust-opacity nil -5)))
(global-set-key (kbd "M-C-9") '(lambda () (interactive) (adjust-opacity nil 5)))
(global-set-key (kbd "M-C-0") '(lambda () (interactive) (modify-frame-parameters nil `((alpha . 100)))))
#+END_SRC
** theme
#+BEGIN_SRC emacs-lisp
(use-package atom-one-dark-theme
  :ensure t
  :init (load-theme 'atom-one-dark t))
#+END_SRC
** indent-guide
#+BEGIN_SRC emacs-lisp
  (use-package indent-guide
    :ensure t
    :init 
    (progn
      (indent-guide-global-mode)
      ))
#+END_SRC
** hideshowvis
#+BEGIN_SRC emacs-lisp
;  (use-package hideshowvis
;    :ensure t
;    :init 
;    (progn
;      (autoload 'hideshowvis-enable "hideshowvis" "Highlight foldable regions")
;      (autoload 'hideshowvis-minor-mode
;        "hideshowvis"
;        "Will indicate regions foldable with hideshow in the fringe."
;        'interactive)
;      (dolist (hook (list 'emacs-lisp-mode-hook
;                          'c++-mode-hook
;                          'js-mode-hook))
;        (add-hook hook 'hideshowvis-enable))
;      ;(hideshowvis-symbols)
;      ))
#+END_SRC
** which-key
#+BEGIN_SRC emacs-lisp
(use-package which-key
  :ensure t
  :init
  (progn
    (require 'which-key)
    (which-key-mode)))
#+END_SRC
* IDO
#+BEGIN_SRC emacs-lisp
  ;; Use C-f during file selection to switch to regular find-file
  (ido-mode t)
  (ido-everywhere t)
  (setq ido-enable-flex-matching t)
  (setq ido-use-filename-at-point nil)
  (setq ido-auto-merge-work-directories-length 0)
  (setq ido-use-virtual-buffers t)

  ;; Use smex to handle M-x
  (use-package smex
    :ensure t
    :init (progn
            (global-set-key [remap execute-extended-command] 'smex)))

  (use-package idomenu :ensure t
    :init (progn
  ;; Allow the same buffer to be open in different frames
  (setq ido-default-buffer-method 'selected-window)))
#+END_SRC
* find-file-in-project
#+BEGIN_SRC emacs-lisp
(use-package find-file-in-project
    :ensure t
    :init
    (progn
    (global-set-key (kbd "C-x f") 'find-file-in-project)
      ))
#+END_SRC
* company
#+BEGIN_SRC emacs-lisp
(use-package company
    :ensure t
    :init
    (progn
      (global-company-mode t)
      (define-key company-active-map (kbd "RET") nil)
      (define-key company-active-map (kbd "ESC") 'company-abort)
      ;(auto-completion :disabled-for org git)
      (setq company-idle-delay 0.125
            company-minimum-prefix-length 1
            company-require-match nil
            company-transformers '(company-sort-by-occurrence)
            company-dabbrev-ignore-case nil
            company-dabbrev-downcase nil
            company-frontends '(company-pseudo-tooltip-unless-just-one-frontend
                                company-preview-frontend
                                company-echo-metadata-frontend))
      (add-hook 'php-mode-hook
                (lambda ()
                  (set (make-local-variable 'company-backends)
                       '((company-dabbrev-code company-yasnippet)))))
      (add-hook 'web-mode-hook
                (lambda ()
                  (set (make-local-variable 'company-backends)
                       '((company-dabbrev-code company-yasnippet)))))
      (add-hook 'css-mode-hook
                (lambda ()
                  (set (make-local-variable 'company-backends)
                       '((company-dabbrev-code company-yasnippet)))))

      ))
#+END_SRC
* company-quickhelp
#+BEGIN_SRC emacs-lisp
  (use-package company-quickhelp
    :ensure t
    :init 
    (progn
      (company-quickhelp-mode 1)
      ))
#+END_SRC
* web-mode
#+BEGIN_SRC emacs-lisp
  (use-package web-mode
    :ensure t
    :init
    (progn
      (add-to-list 'auto-mode-alist '("\\.phtml$" . web-mode))
      (add-to-list 'auto-mode-alist '("\\.ftl$" . web-mode))
      (add-to-list 'auto-mode-alist '("\\.tpl\\.php" . web-mode))
      (add-to-list 'auto-mode-alist '("\\.html?" . web-mode))
      (add-to-list 'auto-mode-alist '("\\.jsx$" . web-mode))
      ;; indentation
      ;; HTML offset indentation
      (setq web-mode-markup-indent-offset 2)
      ;; CSS offset indentation
      (setq web-mode-code-indent-offset 2)
      ;; Script offset indentation (for JavaScript, Java, PHP, etc.)
      (setq web-mode-css-indent-offset 2)
      ;; HTML content indentation
      ;;(setq web-mode-indent-style 2)

      ;; padding
      ;; For <style> parts
      (setq web-mode-style-padding 1)
      ;; For <script> parts
      (setq web-mode-script-padding 1)
      ;; For multi-line blocks
      (setq web-mode-block-padding 0)

      (setq web-mode-disable-auto-pairing t)

      ;; for better jsx syntax-highlighting in web-mode
      ;; - courtesy of Patrick @halbtuerke
      (defadvice web-mode-highlight-part (around tweak-jsx activate)
        (if (equal web-mode-content-type "jsx")
            (let ((web-mode-enable-part-face nil))
              ad-do-it)
          ad-do-it))

      ))

#+END_SRC
* js2-mode
#+BEGIN_SRC emacs-lisp
  (use-package js2-mode
    :ensure t
    :config
    (progn 
      (add-to-list 'auto-mode-alist '("\\.js$" . js2-mode))
      ;(add-to-list 'auto-mode-alist '("\\.jsx$" . js2-mode))
      ))
#+END_SRC
* js-doc
#+BEGIN_SRC emacs-lisp
  (use-package js-doc
    :ensure t
    :config
    (progn 
      (add-hook 'js2-mode-hook
                #'(lambda ()
                    (define-key js2-mode-map "\C-ci" 'js-doc-insert-function-doc)
                    (define-key js2-mode-map "@" 'js-doc-insert-tag)))
      ))
#+END_SRC
* tern
#+BEGIN_SRC emacs-lisp
  (use-package tern
    :ensure t
    :config
    (progn 
      (setq tern-command (append tern-command '("--no-port-file")))
      (add-hook 'js-mode-hook (lambda () (tern-mode t)))
      ))
#+END_SRC
* company-tern
#+BEGIN_SRC emacs-lisp
  (use-package company-tern
    :ensure t
    :init
    (progn
      (add-hook 'js-mode-hook
                (lambda ()
                  (set (make-local-variable 'company-backends)
                       '((company-tern)))))
      ))
#+END_SRC
* emmet-mode
#+BEGIN_SRC emacs-lisp
  (use-package emmet-mode
    :ensure t
    :init 
    (progn
      (add-hook 'sgml-mode-hook 'emmet-mode) ;; Auto-start on any markup modes
      (add-hook 'css-mode-hook  'emmet-mode) ;; enable Emmet's css abbreviation.
      (add-hook 'web-mode-hook  'emmet-mode) ;; enable Emmet's css abbreviation.
      ))
#+END_SRC
* evil
#+BEGIN_SRC emacs-lisp
;  (use-package evil
;    :ensure t
;    :init
;    (progn
;      (setq evil-want-fine-undo t)
;      ;(setq evil-default-state 'insert)
;     ;(evil-mode 1)
;      (setcdr evil-insert-state-map nil)
;      (define-key evil-insert-state-map [escape] 'evil-normal-state)
;      (define-key evil-insert-state-map
;        (read-kbd-macro evil-toggle-key) 'evil-emacs-state))
;
;
;    ;;;; Support
;    (defmacro without-evil-mode (&rest do-this)
;      ;; Check if evil-mode is on, and disable it temporarily
;      `(let ((evil-mode-is-on (evil-mode?)))
;         (if evil-mode-is-on
;             (disable-evil-mode))
;         (ignore-errors
;           ,@do-this)
;         (if evil-mode-is-on
;             (enable-evil-mode))))
;
;    (defmacro evil-mode? ()
;      "Checks if evil-mode is active. Uses Evil's state to check."
;      `evil-state)
;
;    (defmacro disable-evil-mode ()
;      "Disable evil-mode with visual cues."
;      `(progn
;         (evil-mode 0)
;         (message "Evil mode disabled")))
;
;    (defmacro enable-evil-mode ()
;      "Enable evil-mode with visual cues."
;      `(progn
;         (evil-mode 1)
;         (message "Evil mode enabled")))
;
;  ;;;; Clipboard bypass
;
;    ;; delete: char
;    (evil-define-operator evil-destroy-char (beg end type register yank-handler)
;      :motion evil-forward-char
;      (evil-delete-char beg end type ?_))
;
;    ;; delete: char (backwards)
;    (evil-define-operator evil-destroy-backward-char (beg end type register yank-handler)
;      :motion evil-forward-char
;      (evil-delete-backward-char beg end type ?_))
;
;    ;; delete: text object
;    (evil-define-operator evil-destroy (beg end type register yank-handler)
;      "Vim's 's' without clipboard."
;      (evil-delete beg end type ?_ yank-handler))
;
;    ;; delete: to end of line
;    (evil-define-operator evil-destroy-line (beg end type register yank-handler)
;      :motion nil
;      :keep-visual t
;      (interactive "<R><x>")
;      (evil-delete-line beg end type ?_ yank-handler))
;
;    ;; delete: whole line
;    (evil-define-operator evil-destroy-whole-line (beg end type register yank-handler)
;      :motion evil-line
;      (interactive "<R><x>")
;      (evil-delete-whole-line beg end type ?_ yank-handler))
;
;    ;; change: text object
;    (evil-define-operator evil-destroy-change (beg end type register yank-handler delete-func)
;      (evil-change beg end type ?_ yank-handler delete-func))
;
;    ;; paste: before
;    (defun evil-destroy-paste-before ()
;      (interactive)
;      (without-evil-mode
;       (delete-region (point) (mark))
;       (evil-paste-before 1)))
;
;    ;; paste: after
;    (defun evil-destroy-paste-after ()
;      (interactive)
;      (without-evil-mode
;       (delete-region (point) (mark))
;       (evil-paste-after 1)))
;
;    ;; paste: text object
;    (evil-define-operator evil-destroy-replace (beg end type register yank-handler)
;      (evil-destroy beg end type register yank-handler)
;      (evil-paste-before 1 register))
;
;
;    ;; Clipboard bypass key rebindings
;    (define-key evil-normal-state-map "s" 'evil-destroy)
;    (define-key evil-normal-state-map "S" 'evil-destroy-line)
;    (define-key evil-normal-state-map "c" 'evil-destroy-change)
;    (define-key evil-normal-state-map "x" 'evil-destroy-char)
;    (define-key evil-normal-state-map "X" 'evil-destroy-whole-line)
;    (define-key evil-normal-state-map "Y" 'evil-copy-to-end-of-line)
;    (define-key evil-visual-state-map "P" 'evil-destroy-paste-before)
;    (define-key evil-visual-state-map "p" 'evil-destroy-paste-after))
#+END_SRC
* flycheck
#+BEGIN_SRC emacs-lisp
  (use-package let-alist
    :ensure t
    :init
    (use-package flycheck
      :ensure t
      :init
      (progn
        (require 'flycheck)
        (defun my--flycheck-display-errors-function (errors)
          (mapc (lambda (err)
                  (message "FlyC: %s" (flycheck-error-message err)) (sit-for 1))
                errors))
        ;; disable jshint since we prefer eslint checking
        (setq-default flycheck-disabled-checkers
                      (append flycheck-disabled-checkers
                              '(javascript-jshint)))
        ;; use eslint with web-mode for jsx files
        (flycheck-add-mode 'javascript-eslint 'web-mode)

        ;; customize flycheck temp file prefix
        (setq-default flycheck-temp-prefix ".flycheck")

        ;; disable json-jsonlist checking for json files
        (setq-default flycheck-disabled-checkers
                      (append flycheck-disabled-checkers
                              '(json-jsonlist)))

        (setq flycheck-highlighting-mode nil
              flycheck-display-errors-function 'my--flycheck-display-errors-function)
        (add-hook 'js-mode-hook
                  (lambda () (flycheck-mode t)))
        (add-hook 'web-mode-hook
                  (lambda () (flycheck-mode t))))))
#+END_SRC
* ox-reveal
#+BEGIN_SRC emacs-lisp
  (use-package ox-reveal
    :ensure t
    :init
    (progn
      (setq org-reveal-root "file://~/emacs.d/lib/reveal.js/")
      ;(setq org-reveal-root "http://cdn.bootcss.com/reveal.js/3.3.0/")
      (setq org-reveal-hlevel 2)))
#+END_SRC
* smartparens
#+BEGIN_SRC emacs-lisp
 (use-package smartparens
   :ensure t
   :init
   (progn
     (require 'smartparens-config)
     (defun sp-pair-on-newline (id action context)
       "Put trailing pair on newline and return to point."
       (save-excursion
         (newline)
         (indent-according-to-mode)))
 
     (defun sp-pair-on-newline-and-indent (id action context)
       "Open a new brace or bracket expression, with relevant newlines and indent. "
       (sp-pair-on-newline id action context)
       (indent-according-to-mode))
 
     (sp-pair "{" nil :post-handlers
              '(:add ((lambda (id action context)
                        (sp-pair-on-newline-and-indent id action context)) "RET")))
     (sp-pair "[" nil :post-handlers
              '(:add ((lambda (id action context)
                        (sp-pair-on-newline-and-indent id action context)) "RET")))
 
     (sp-local-pair '(markdown-mode gfm-mode) "*" "*"
                    :unless '(sp-in-string-p)
                    :actions '(insert wrap))
 
     (smartparens-global-mode t)
     (setq sp-highlight-pair-overlay nil)
))

#+END_SRC
* multiple cursors
#+BEGIN_SRC emacs-lisp
  (use-package multiple-cursors
    :ensure t
    :init 
    (progn
      (use-package region-bindings-mode
        :ensure t
        :init
        (progn
          (require 'region-bindings-mode)
          (region-bindings-mode-enable)
          ;Binding mouse events
          (global-unset-key (kbd "M-<down-mouse-1>"))
          (global-set-key (kbd "M-<mouse-1>") 'mc/add-cursor-on-click)

          (define-key region-bindings-mode-map "a" 'mc/mark-all-like-this)
          (define-key region-bindings-mode-map "p" 'mc/mark-previous-like-this)
          (define-key region-bindings-mode-map "n" 'mc/mark-next-like-this)
          (define-key region-bindings-mode-map "m" 'mc/mark-more-like-this-extended)
          (define-key region-bindings-mode-map ">" 'mc/unmark-previous-like-this)
          (define-key region-bindings-mode-map "<" 'mc/unmark-next-like-this)
          (define-key region-bindings-mode-map "P" 'mc/skip-to-previous-like-this)
          (define-key region-bindings-mode-map "N" 'mc/skip-to-next-like-this)))))
#+END_SRC
* ztree
#+BEGIN_SRC emacs-lisp
  (use-package ztree
    :ensure t
      )
#+END_SRC
* Auto Sync
#+BEGIN_SRC emacs-lisp
  (defcustom auto-sync-script-name ".sync"
    "customized scripts which to be executed after save-buffer done")

  (defun auto-sync-search-script-hierarchy (dir)
    (progn
      (while (not (or (equal dir "/")
                      (file-exists-p
                       (concat dir auto-sync-script-name))))
        (setq dir (file-name-as-directory
                   (file-name-directory
                    (directory-file-name dir)))))
      (if (equal dir "/") nil dir)))

  (defun auto-sync-start-process (dir)

    (let ((script (concat dir auto-sync-script-name))
          (process-obj (get-process "auto-sync-process"))
          (fold (progn (string-match dir dir) (replace-match "" nil nil (file-name-directory buffer-file-name) 0))))
      (unless (and process-obj
                   (eq (process-status process-obj) 'run))
        (start-process "auto-sync-process"
                       (get-buffer-create "*Messages*")
                       script "upload" fold (file-name-nondirectory buffer-file-name)))))
  (defun auto-sync-run ()
    (interactive)
    (let ((dir (auto-sync-search-script-hierarchy
                (file-name-directory buffer-file-name))))
      (message dir)
      (if dir
          (if (auto-sync-start-process dir)
              (message "Synchronized %s" buffer-file-name)
            (message "Synchronize %s failed" buffer-file-name)
            (message "Wrote %s done" buffer-file-name)))))

  (add-hook 'after-save-hook 'auto-sync-run)

#+END_SRC
* Org
#+BEGIN_SRC emacs-lisp
(org-babel-load-file (concat emacs-base-dir "org-mode.org"))
#+END_SRC
* Cal
** cal-china-x
#+BEGIN_SRC emacs-lisp
  (use-package cal-china-x
    :ensure t
    :init
    (progn
(require 'cal-china-x)
(setq mark-holidays-in-calendar t)
    (setq cal-china-x-important-holidays cal-china-x-chinese-holidays)
    (setq calendar-holidays cal-china-x-important-holidays)))
#+END_SRC
* yasnippet
#+BEGIN_SRC emacs-lisp
  ;use-package yasnippet
  ; :ensure t
  ; :init 
  ; (progn 
  ;   (yas-global-mode 1)
  ;   (add-hook 'web-mode-hook #'(lambda () (yas-activate-extra-mode 'html-mode)))
  ;   ))
#+END_SRC
* youdao-dictionary
#+BEGIN_SRC emacs-lisp
  (use-package youdao-dictionary
    :ensure t
    :init 
    (progn 
      ;; Enable Cache
      (setq url-automatic-caching t)

      ;; Example Key binding
      (global-set-key (kbd "C-c y") 'youdao-dictionary-search-at-point+)
      ))
#+END_SRC
* gnus
#+BEGIN_SRC emacs-lisp
(defun my-gnus-group-list-subscribed-groups ()
  "List all subscribed groups with or without un-read messages"
  (interactive)
  (gnus-group-list-all-groups 5)
  )

(add-hook 'gnus-group-mode-hook
          ;; list all the subscribed groups even they contain zero un-read messages
          (lambda () (local-set-key "o" 'my-gnus-group-list-subscribed-groups ))
          )

(setq-default
  gnus-summary-line-format "%U%R%z %(%&user-date;  %-15,15f  %B%s%)\n"
  gnus-user-date-format-alist '((t . "%Y-%m-%d %H:%M"))
  gnus-summary-thread-gathering-function 'gnus-gather-threads-by-references
  gnus-sum-thread-tree-false-root ""
  gnus-sum-thread-tree-indent " "
  gnus-sum-thread-tree-leaf-with-other "├► "
  gnus-sum-thread-tree-root ""
  gnus-sum-thread-tree-single-leaf "╰► "
  gnus-sum-thread-tree-vertical "│")
(setq gnus-thread-sort-functions
      '(
        (not gnus-thread-sort-by-date)
        (not gnus-thread-sort-by-number)
        ))

;(setq message-send-mail-function 'smtpmail-send-it
;      smtpmail-starttls-credentials '(("smtp.gmail.com" 587 nil nil))
;      smtpmail-auth-credentials "~/.authinfo.gpg"
;      smtpmail-default-smtp-server "smtp.gmail.com"
;      smtpmail-smtp-server "smtp.gmail.com"
;      smtpmail-smtp-service 587
;      smtpmail-local-domain "localhost")


;; Fetch only part of the article if we can.  I saw this in someone
;; else's .gnus
(setq gnus-read-active-file 'some)

;; Tree view for groups.  I like the organisational feel this has.
;(add-hook 'gnus-group-mode-hook 'gnus-topic-mode)

;; Threads!  I hate reading un-threaded email -- especially mailing
;; lists.  This helps a ton!
(setq gnus-summary-thread-gathering-function
      'gnus-gather-threads-by-subject)

;; Also, I prefer to see only the top level message.  If a message has
;; several replies or is part of a thread, only show the first
;; message.  'gnus-thread-ignore-subject' will ignore the subject and
;; look at 'In-Reply-To:' and 'References:' headers.
(setq gnus-thread-hide-subtree t)
(setq gnus-thread-ignore-subject t)

;(setq mm-text-html-renderer 'eww) 

;stop ask me "how many articles from" and
;show-me-all-my-mail-all-ways.
;(setq gnus-large-newsgroup 'nil)

(defun message-select-forwarded-email-tags ()
  "select the <#mml-or-what-ever> tags in message-mode"
  (interactive)
  (let (start rlt)
    (when (search-forward "<#")
      (setq start (point))
      (push-mark (point) t t)
      (goto-char (point-max))
      (search-backward ">")
      (forward-char)
      (setq rlt t))
    rlt))

(defun message-copy-select-forwarded-email-tags ()
  "copy the <#mml-or-what-ever> tags in message-mode"
  (interactive)
  (save-excursion
    (cond
     ((message-select-forwarded-email-tags)
      (copy-region-as-kill (region-beginning) (region-end))
      (message "forwarded email tags copied!"))
     (t (message "NO forwarded email tags found!"))
     )
    ))

#+END_SRC
* bbdb
#+BEGIN_SRC emacs-lisp
;  (use-package bbdb
;    :ensure t
;    :init 
;    (progn
      ;(bbdb-initialize)
;      ))
#+END_SRC
* Dired
#+BEGIN_SRC emacs-lisp
  (setq dired-recursive-deletes 'always)
  (setq dired-recursive-copies 'always)
  (setq dired-dwim-target t)

  (defun ergoemacs-open-in-external-app ()
    "Open the current file or dired marked files in external app."
    (interactive)
    (let ( doIt
           (myFileList
            (cond
             ((string-equal major-mode "dired-mode") (dired-get-marked-files))
             (t (list (buffer-file-name))) ) ) )

      (setq doIt (if (<= (length myFileList) 5)
                     t
                   (y-or-n-p "Open more than 5 files?") ) )

      (when doIt
        (cond
         ((string-equal system-type "windows-nt")
          (mapc (lambda (fPath) (w32-shell-execute "open" (replace-regexp-in-string "/" "\\" fPath t t)) ) myFileList)
          )
         ((string-equal system-type "darwin")
          (mapc (lambda (fPath) (shell-command (format "open \"%s\"" fPath)) )  myFileList) )
         ((string-equal system-type "gnu/linux")
          (mapc (lambda (fPath) (let ((process-connection-type nil)) (start-process "" nil "xdg-open" fPath)) ) myFileList) ) ) ) ) )

  (defun ergoemacs-open-in-desktop ()
    "Show current file in desktop (OS's file manager)."
    (interactive)
    (cond
     ((string-equal system-type "windows-nt")
      (w32-shell-execute "explore" (replace-regexp-in-string "/" "\\" default-directory t t)))
     ((string-equal system-type "darwin") (shell-command "open ."))
     ((string-equal system-type "gnu/linux")
      (let ((process-connection-type nil)) (start-process "" nil "xdg-open" "."))
      ;; (shell-command "xdg-open .") ;; 2013-02-10 this sometimes froze emacs till the folder is closed. ⁖ with nautilus
      ) ))
  (add-hook 'dired-mode-hook
            #'(lambda ()
                (define-key dired-mode-map (kbd "RET") 'dired-find-alternate-file) ; was dired-advertised-find-file

                (define-key dired-mode-map (kbd "^") (lambda () (interactive) (find-alternate-file "..")))  ; was dired-up-directory
                (define-key dired-mode-map "\C-co" 'ergoemacs-open-in-external-app)
                (define-key dired-mode-map "\C-cO" 'ergoemacs-open-in-desktop)))
#+END_SRC
* Load Customize
#+BEGIN_SRC emacs-lisp
(load custom-file 'noerror)
#+END_SRC
