* Base
** Load path etc.
#+BEGIN_SRC emacs-lisp
(let ((elisp-dir (expand-file-name "src" emacs-base-dir)))
  ;; add the src directory to the load path
  (add-to-list 'load-path elisp-dir)
  ;; load specific files
  (when (file-exists-p elisp-dir)
    (let ((default-directory elisp-dir))
      (normal-top-level-add-subdirs-to-load-path))))
(setq autoload-file (concat emacs-base-dir "loaddefs.el"))
(setq package-user-dir (concat emacs-base-dir "elpa"))
(setq custom-file (concat emacs-base-dir "custom.el"))
#+END_SRC
* Library
** Add some useful libraries

[[https://github.com/jwiegley/emacs-async][async]], [[https://github.com/magnars/s.el][s]], [[https://github.com/magnars/dash.el][dash]], and [[http://elpa.gnu.org/packages/cl-lib.html][cl-lib]] are libraries for asynchronous processing, string manipulation, list manipulation and backward compatibility respectively.

#+BEGIN_SRC emacs-lisp
(use-package async
  :ensure t
  :commands (async-start))

(use-package cl-lib
  :ensure t)

(use-package dash
  :ensure t)

(use-package s
  :ensure t)
#+END_SRC

* Defaults
** Startup
*** Disabling some GUI elements
#+BEGIN_SRC emacs-lisp
  (when window-system
    (tool-bar-mode 0)
    (scroll-bar-mode 0)
    (menu-bar-mode 0)
    (tooltip-mode 0))
#+END_SRC

*** Set the initial frame size

Frames in Emacs parlance are the equivalent of windows in normal usage. So, when you open Emacs, it opens a /frame/ and not a window. Windows are the what splits are referred to. For further reference [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Frames.html][look it up in the Emacs manual]].

#+BEGIN_SRC emacs-lisp
;; initial window
(setq initial-frame-alist
      '((width . 102)   ; characters in a line
        (height . 54))) ; number of lines

;; sebsequent frame
(setq default-frame-alist
      '((width . 100)   ; characters in a line
        (height . 52))) ; number of lines
#+END_SRC

*** Set the cursor shape

Since I use a modal configuration, it is so easy to detect modes by just changing the cursor shape. Also, the "bar" cursor feels more natural because that's what most application outside of Emacs use anyway. Also, while I'm at it, I don't want the cursor to blink either.

#+BEGIN_SRC emacs-lisp
;; Bar cursor
(setq-default cursor-type '(bar . 1))
;; Don't blink the cursor
(blink-cursor-mode -1)
#+END_SRC

*** Initial screen

The default screen of Emacs is just so useless and cluttered with links and text and help pages. I just need a simple start screen which gently reminds me some things that are important while staying out of the most of the time. This is also called the *scratch* buffer.

#+BEGIN_SRC emacs-lisp
;; No welcome screen - opens directly in scratch buffer
(setq inhibit-startup-message t
      ;initial-scratch-message ""
      initial-major-mode 'fundamental-mode
      inhibit-splash-screen t)
#+END_SRC

*** Startup echo message

There is a small advert for GNU that is displayed in the mini-buffer during startup and, of course, [[http://emacs.stackexchange.com/questions/432/how-to-change-default-minibuffer-message][there is a way to change it]].

#+BEGIN_SRC emacs-lisp
;; Change the echo message
(defun display-startup-echo-area-message ()
  (message "Let the games begin!"))
#+END_SRC
*** Frame title format
#+BEGIN_SRC emacs-lisp
(setq frame-title-format
      '((:eval (if (buffer-file-name)
                   (abbreviate-file-name (buffer-file-name))
                 "%b"))))
#+END_SRC

** Backups
#+BEGIN_SRC emacs-lisp
(setq backup-directory-alist
      `((".*" . ,temporary-file-directory)))
;;varsion control
(setq version-control 1)
(setq kept-old-versions 2)
(setq kept-new-versions 5)
(setq delete-old-versions t)
(setq make-backup-files nil)
(setq backup-by-copying t)
#+END_SRC
** Auto saving

I make sure Emacs auto-saves often but the result is that it messes up my file tree. So, let's ask Emacs to store its backups in some temporary directory.

#+BEGIN_SRC emacs-lisp
(setq auto-save-file-name-transforms
      `((".*" ,temporary-file-directory t)) create-lockfiles nil)
#+END_SRC

** File encoding system

UTF-8 works for most of the files I tend to use

#+BEGIN_SRC emacs-lisp
(prefer-coding-system 'utf-8)
(setq-default buffer-file-coding-system 'utf-8-auto-unix)
#+END_SRC

** Error message

Mac has an [[http://stuff-things.net/2015/10/05/emacs-visible-bell-work-around-on-os-x-el-capitan/][annoying bug]] when visibly warning you about errors. I hate it. And while we're at it, let's ask Emacs to ignore the audible warning too.

#+BEGIN_SRC emacs-lisp
(setq visible-bell nil)
(setq ring-bell-function 'ignore)
#+END_SRC

** Truncating lines

Emacs has an option to [[https://www.emacswiki.org/emacs/TruncateLines][wrap lines]] which is disabled by default. What this means is that, if the text goes beyond the screen, it will wrap it so that you can see all the text. However, it wraps it with these weird indicators that I find more annoying. Plus, I make sure my code stays within 100 characters always and prefer the soft line wrap while writing prose. Let's make sure it doesn't wrap again.

#+BEGIN_SRC emacs-lisp
(setq-default truncate-lines t)
#+END_SRC

** Large file warning

Whenever, a large file (by Emacs standards) is opened, it asks for confirmation whether we really want to open it but the problem is the limit for this file is set pretty low. Let's increase it a bit so that it doesn't prompt so often.

#+BEGIN_SRC emacs-lisp
(setq large-file-warning-threshold (* 15 1024 1024))
#+END_SRC

** Lazier prompting

While we are in the topic of prompting, a lot of the default prompts ask for a =yes= or a =no=. I'm lazy and so I don't want to type the full words. Let's just make it accept =y= or =n=.

#+BEGIN_SRC emacs-lisp
(fset 'yes-or-no-p 'y-or-n-p)
#+END_SRC

** Expand some words and auto-correct

=abbrev-mode= or abbreviation mode is a built-in mode that auto-corrects the word you mistype on pressing space. For how I practically use it, see [[*Add for auto correction][the auto-correction section]].

#+BEGIN_SRC emacs-lisp
(setq save-abbrevs 'silently)
(setq-default abbrev-mode t)
#+END_SRC

** =gdb=

[[https://www.gnu.org/software/gdb/][gdb]] is the GNU debugger which is used to debug programs. Let's make it multi-windowed like all the other debuggers out there.

#+BEGIN_SRC emacs-lisp
(setq gdb-many-windows t
      gdb-show-main t)
#+END_SRC

** =tramp=

[[https://www.emacswiki.org/emacs/TrampMode][Tramp]] lets you edit files remotely from your local Emacs which is useful because it lets you have all the default configuration. Let's make sure the default protocol is =ssh=.

#+BEGIN_SRC emacs-lisp
(setq tramp-default-method "ssh"
      tramp-backup-directory-alist backup-directory-alist
      tramp-ssh-controlmaster-options "ssh")
#+END_SRC

** Move correctly over camelCased words

=subword-mode= is a built-in mode that helps moving over camelCase words correctly.

#+BEGIN_SRC emacs-lisp
(subword-mode)
#+END_SRC

** Understand the more common =sentence=

By default, Emacs thinks a sentence is a full-stop followed by 2 spaces. Let's make it full-stop and 1 space.

#+BEGIN_SRC emacs-lisp
(setq sentence-end-double-space nil)
#+END_SRC

** Recenter screen

Emacs lets you move the current line to the top, middle or bottom of the screen to get appropriate context. The default goes to the middle first. I prefer that the default goes to the top first. Let's change this.

#+BEGIN_SRC emacs-lisp
(setq recenter-positions '(top middle bottom))
#+END_SRC

** Better wild cards in search

The built-in incremental search is pretty good but the most common regex I type is =.*= which stands for anything. This makes sure space between words acts the same way. It's much better for me to use it now.

#+BEGIN_SRC emacs-lisp
(setq search-whitespace-regexp ".*?")
#+END_SRC

** Persistent history

I prefer to have some persistent history for some prompts.

#+BEGIN_SRC emacs-lisp
(savehist-mode)

(setq recentf-max-saved-items 1000
      recentf-exclude '("/tmp/" "/ssh:"))
(recentf-mode)
#+END_SRC
** Narrow to region

This is such a an amazing feature but is disabled by default. Let's re-enable it. For further reference on narrow region, [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Narrowing.html][refer to the Emacs manual]].

#+BEGIN_SRC emacs-lisp
(put 'narrow-to-region 'disabled nil)
#+END_SRC

** PDF files

Emacs has the built-in [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Document-View.html][DocView]] mode which lets me view PDFs. Since I use Org and note taking extensively, I actually prefer reading PDFs in Emacs. Not to mention, this is one of the few PDF readers that lets me view the PDF in split-views which is immensely useful while reading research papers.

#+BEGIN_SRC emacs-lisp
(setq doc-view-continuous t)
#+END_SRC

** Window management

[[https://www.emacswiki.org/emacs/WinnerMode][Winner mode]] is an Emacs built-in package that lets you undo and redo window configurations. Incredibly useful since I keep splitting and merging windows all the time. Let's enable it.

#+BEGIN_SRC emacs-lisp
(when (fboundp 'winner-mode)
  (winner-mode 1))
#+END_SRC

** Recent files

An Emacs "mode" is a collection of behavior. It has both major and minor modes. One such useful mode is the =recentf-mode=, which stands for recent files mode. Let's give configure some options and enable it.

#+BEGIN_SRC emacs-lisp
;; Recentf mode changes
(setq recentf-max-saved-items 1000
      recentf-exclude '("/tmp/" "/ssh:" ".*/personal\\.*" ".*\\.emacs\\.*"))
(recentf-mode)
#+END_SRC

** Fullscreen

In Mac, the default fullscreen goes to a new workspace. Change this behavior so that it's non-native.

#+BEGIN_SRC emacs-lisp :tangle no
(setq ns-use-native-fullscreen nil)
#+END_SRC

** Fonts
#+BEGIN_SRC emacs-lisp
(use-package chinese-fonts-setup
  :ensure t
  :config
  (chinese-fonts-setup-enable))
#+END_SRC
** Mouse wheel scroll
#+BEGIN_SRC emacs-lisp
(setq mouse-wheel-scroll-amount '(1 ((shift) . 1)((control)))
mouse-wheel-progressive-speed nil
scroll-step 1)
#+END_SRC
* Helper functions
#+BEGIN_SRC emacs-lisp
(defun kill-default-buffer ()
  "Kill the currently active buffer -- set to C-x k so that users are not asked which buffer they want to kill."
  (interactive)
  (let (kill-buffer-query-functions) (kill-buffer)))

(defun kill-buffer-if-file (buf)
  "Kill a buffer only if it is file-based."
  (when (buffer-file-name buf)
    (when (buffer-modified-p buf)
        (when (y-or-n-p (format "Buffer %s is modified - save it?" (buffer-name buf)))
            (save-some-buffers nil buf)))
    (set-buffer-modified-p nil)
    (kill-buffer buf)))

(defun kill-all-buffers ()
    "Kill all file-based buffers."
    (interactive)
    (mapc (lambda (buf) (kill-buffer-if-file buf))
     (buffer-list)))

(defun kill-buffer-and-window ()
  "Close the current window and kill the buffer it's visiting."
  (interactive)
  (progn
    (kill-buffer)
    (delete-window)))

(defun create-new-buffer ()
  "Create a new buffer named *new*[num]."
  (interactive)
  (switch-to-buffer (generate-new-buffer-name "*new*")))

(defun insert-semicolon-at-end-of-line ()
  "Add a closing semicolon from anywhere in the line."
  (interactive)
  (save-excursion
    (end-of-line)
    (insert ";")))

(defun comment-current-line-dwim ()
  "Comment or uncomment the current line."
  (interactive)
  (save-excursion
    (push-mark (beginning-of-line) t t)
    (end-of-line)
    (comment-dwim nil)))

(defun newline-anywhere ()
  "Add a newline from anywhere in the line."
  (interactive)
  (end-of-line)
  (newline-and-indent))

(defun increase-window-height (&optional arg)
  "Make the window taller by one line. Useful when bound to a repeatable key combination."
  (interactive "p")
  (enlarge-window arg))

(defun decrease-window-height (&optional arg)
  "Make the window shorter by one line. Useful when bound to a repeatable key combination."
  (interactive "p")
  (enlarge-window (- 0 arg)))

(defun decrease-window-width (&optional arg)
  "Make the window narrower by one column. Useful when bound to a repeatable key combination."
  (interactive "p")
  (enlarge-window (- 0 arg) t))

(defun increase-window-width (&optional arg)
  "Make the window wider by one column. Useful when bound to a repeatable key combination."
  (interactive "p")
  (enlarge-window arg t))

;; Create a new instance of emacs
(when window-system
  (defun new-emacs-instance ()
    (interactive)
    (let ((path-to-emacs
           (locate-file invocation-name
                        (list invocation-directory) exec-suffixes)))
      (call-process path-to-emacs nil 0 nil))))
#+END_SRC
* Modal states
** General
#+BEGIN_SRC emacs-lisp
  (use-package general
    :ensure t
    :init
    (general-create-definer general-leader-key
                            :states '(normal insert emacs visual)
                            :non-normal-prefix "M-SPC"
                            :prefix "SPC"))
#+END_SRC
*** Default modal keybindings
#+BEGIN_SRC emacs-lisp
#+END_SRC

** Evil
#+BEGIN_SRC emacs-lisp
  (use-package evil
    :ensure t
    :demand t
    :init
    (setq evil-emacs-state-cursor 'bar)
    (setq evil-default-state 'emacs)
    (setq evil-disable-insert-state-bindings t)
    :config
    (evil-mode 1)
  :general 
    (general-define-key :states '(insert emacs)
                        "f" (general-key-dispatch 'self-insert-command
                              :timeout 0.25
                              "d" 'evil-normal-state))
 (general-leader-key 
    "hT" '(evil-totur-start)
    "se" '(evil-iedit-state/iedit-mode)
    ))
#+END_SRC
** Hydras

[[https://github.com/abo-abo/hydra][Hydra]] is not strictly a modal package but it is one that lets you define sticky bindings and I would call it semi-modal. I love it and need it. Currently, I don't define an hydras. They are defined under appropriate sections.

#+BEGIN_SRC emacs-lisp
(use-package hydra
  :ensure t)
#+END_SRC

* Key hints
** Which key

Emacs has 100s of bindings and it is impossible to remember them all. Sometimes I can remember the start of a key chord but not the entire one. [[https://github.com/justbur/emacs-which-key][Which-key]] is a package that gives you key hints on delay or if prompted. I really like it and use it extensively to setup the modal state.

#+BEGIN_SRC emacs-lisp
(use-package which-key
  :ensure t
  ;:defer t
  :diminish which-key-mode
  :init
  (setq which-key-sort-order 'which-key-key-order-alpha)
  :general 
    (general-leader-key "?" 
         '(which-key-show-top-level :which-key "top level bindings"))

  :config
  (which-key-mode))
#+END_SRC

** Discover my major

[[https://github.com/steckerhalter/discover-my-major][This package]] helps to discover the major mode bindings. I use it very occasionally and hence not binding it to any modal binding.

#+BEGIN_SRC emacs-lisp
(use-package discover-my-major
  :ensure t
  :general 
  (general-leader-key 
  "hm" '(discover-my-major)
  "hM" '(discover-my-mode)))
#+END_SRC

* File Manager
** dired

[[https://www.gnu.org/software/emacs/manual/html_node/emacs/Dired.html][Dired]] is an amazing file/directory browser that comes bundled with Emacs but I don't like it displaying all the details regarding the files when I open it. I prefer it minimal.

#+BEGIN_SRC emacs-lisp
(use-package dired
  :bind (:map dired-mode-map
              ("C-c C-e" . wdired-change-to-wdired-mode))
  :init
  (setq dired-dwim-target t
        dired-recursive-copies 'always
        dired-recursive-deletes 'always
        dired-listing-switches "-alh")
  :config
  (defun ergoemacs-open-in-external-app ()
    "Open the current file or dired marked files in external app."
    (interactive)
    (let ( doIt
           (myFileList
            (cond
             ((string-equal major-mode "dired-mode") (dired-get-marked-files))
             (t (list (buffer-file-name))) ) ) )

      (setq doIt (if (<= (length myFileList) 5)
                     t
                   (y-or-n-p "Open more than 5 files?") ) )

      (when doIt
        (cond
         ((string-equal system-type "windows-nt")
          (mapc (lambda (fPath) (w32-shell-execute "open" (replace-regexp-in-string "/" "\\" fPath t t)) ) myFileList)
          )
         ((string-equal system-type "darwin")
          (mapc (lambda (fPath) (shell-command (format "open \"%s\"" fPath)) )  myFileList) )
         ((string-equal system-type "gnu/linux")
          (mapc (lambda (fPath) (let ((process-connection-type nil)) (start-process "" nil "xdg-open" fPath)) ) myFileList) ) ) ) ) )

  (defun ergoemacs-open-in-desktop ()
    "Show current file in desktop (OS's file manager)."
    (interactive)
    (cond
     ((string-equal system-type "windows-nt")
      (w32-shell-execute "explore" (replace-regexp-in-string "/" "\\" default-directory t t)))
     ((string-equal system-type "darwin") (shell-command "open ."))
     ((string-equal system-type "gnu/linux")
      (let ((process-connection-type nil)) (start-process "" nil "xdg-open" "."))
      ;; (shell-command "xdg-open .") ;; 2013-02-10 this sometimes froze emacs till the folder is closed. ⁖ with nautilus
      ) ))
  (add-hook 'dired-mode-hook
            #'(lambda ()
                (define-key dired-mode-map (kbd "RET") 'dired-find-alternate-file) ; was dired-advertised-find-file

                (define-key dired-mode-map (kbd "^") (lambda () (interactive) (find-alternate-file "..")))  ; was dired-up-directory
                (define-key dired-mode-map "\C-co" 'ergoemacs-open-in-external-app)
                (define-key dired-mode-map "\C-cO" 'ergoemacs-open-in-desktop)))
  (add-hook 'dired-mode-hook 'dired-hide-details-mode))
#+END_SRC
* Navigation
** Flx

[[https://github.com/lewang/flx][Flx]] is a package that helps in fuzzy file narrowing like [[http://www.sublimetext.com][Sublime Text]]. The most prominent package that uses this is =flx-ido= found in the same repository. I find =ivy='s built-in fuzzy matching more than good enough. However, this is in case I need something different/more and when this is installed, Ivy automatically uses this for fuzzy finding. This is particularly useful if I decide to use [[*Helm][Helm]] full time instead of ivy.

#+BEGIN_SRC emacs-lisp
(use-package flx-ido
  :ensure t
  :defer t)
#+END_SRC
** Smex

[[https://github.com/nonsequitur/smex][smex]] is an amazing program that helps order the =M-x= commands based on usage and recent items. Let's install it.

#+BEGIN_SRC emacs-lisp
(use-package smex
  :ensure t
  :config
  (smex-initialize))
#+END_SRC
** Beacon mode

[[https://github.com/Malabarba/beacon][Beacon]] is just a tiny utility that indicates the cursor position when the cursor moves suddenly. You can also manually invoke it by calling the function =beacon-blink= and it is bound by default.

#+BEGIN_SRC emacs-lisp
  (use-package beacon
    :ensure t
    :demand t
    :diminish beacon-mode
    :general 
    (general-leader-key "sc" 
         '(beacon-blink :which-key "Blink cursor"))
    :config
    (beacon-mode 1))
#+END_SRC

** Undo tree

The default Emacs [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Undo.html][undo]] command is weird. Better undo and redo states are given by [[https://www.emacswiki.org/emacs/UndoTree][undo-tree]] mode and, as an added bonus, also gives a visualization tree

#+BEGIN_SRC emacs-lisp
  (use-package undo-tree
    :ensure t
    :diminish undo-tree-mode
    :general 
    (general-define-key :states '(normal)
                        "br" '(undo-tree-redo)
                        "bu" '(undo-tree-undo)
                        "bU" '(undo-tree-visualize)
                        "U" '(undo-tree-visualize :which-key "undo tree"))
    :config
    (global-undo-tree-mode 1))
#+END_SRC
** Goto the last change

[[https://www.emacswiki.org/emacs/GotoChg][This package]] goes to the last place I made a change in the file, and compliments marks.

#+BEGIN_SRC emacs-lisp
(use-package goto-chg
  :ensure t
  :general 
    (general-leader-key
            "x;" '(goto-last-change :which-key "goto last change")
            "x," '(goto-last-change-reverse :which-key "goto last change reverse")))
#+END_SRC

** Avy

[[https://github.com/abo-abo/avy][Avy]] is a package that lets you jump anywhere on screen based on character, characters, lines or words. It's one of my most used packages.

#+BEGIN_SRC emacs-lisp
(use-package avy
  :ensure t
  :init
  (setq avy-keys-alist
        `((avy-goto-char-timer . (?j ?k ?l ?f ?s ?d ?e ?r ?u ?i))
          (avy-goto-line . (?j ?k ?l ?f ?s ?d ?e ?r ?u ?i))))
  (setq avy-style 'pre)
  :general 
    (general-leader-key
            "jb" '(avy-pop-mark)
            "jj" '(avy-goto-char-timer)
            "jl" '(avy-goto-line)))
#+END_SRC
** Highlight symbol

[[https://github.com/nschum/highlight-symbol.el][This package]] is pretty simple. It adds functionality to highlight the current word or symbol and navigate to other instances.

#+BEGIN_SRC emacs-lisp
(use-package highlight-symbol
  :ensure t
  :general 
    (general-leader-key
            "xn" '(highlight-symbol-next)
            "xp" '(highlight-symbol-prev))
  :config
  (highlight-symbol-nav-mode))
#+END_SRC
** Toggle zoom

I generally have multiple windows open and might need to zoom into one every now and then. I also might split them and change them. I would like to think of [[https://github.com/syohex/emacs-zoom-window][this package]] as smart zoom where I zoom into a window, split further, and have =winner= handle the history and just zoom right back out and continue working on the previous configuration. It also indicates if you are zoomed in or not via the status line color.

#+BEGIN_SRC emacs-lisp
(use-package zoom-window
  :ensure t
  :general 
    (general-leader-key
            "wm" '(zoom-window-zoom :which-key "zoom window")))
#+END_SRC
** Code documentation

[[https://kapeli.com/dash][Dash]] is a nice little app that stores documents offline for reference. Let's [[https://github.com/stanaka/dash-at-point][bring that to Emacs]].

#+BEGIN_SRC emacs-lisp :tangle no
(use-package dash-at-point
  :ensure t
  :bind (("C-c I" . dash-at-point))
  :bind* (("M-m SPC y" . dash-at-point-with-docset)
          ("M-m SPC Y" . dash-at-point)))
#+END_SRC
Which key modal explanation

#+BEGIN_SRC emacs-lisp :tangle no
(which-key-add-key-based-replacements
  "I"     "info at point"
  "SPC y" "documentation prompt"
  "SPC Y" "documentation at point")
#+END_SRC
** Custom functions
*** Open the =config.org= file

This function opens the current file when invoked from anywhere so that I can edit my configuration quickly, whenever I want

#+BEGIN_SRC emacs-lisp
(defun sk/open-config ()
  "Opens the configuration file from anywhere"
  (interactive)
  (find-file (concat user-emacs-directory "config.org")))
(defun sk/open-init ()
  "Opens the configuration file from anywhere"
  (interactive)
  (find-file (concat user-emacs-directory "init.el")))
#+END_SRC

**** Key binding

 #+BEGIN_SRC emacs-lisp
 (general-leader-key 
  "fec" '(sk/open-config :which-key "view config file")
  "fei" '(sk/open-init :which-key "view init file"))
 #+END_SRC
*** Non native full screen

As mentioned [[*Fullscreen][here]], this is to further ensure that we use a non-native fullscreen.

#+BEGIN_SRC emacs-lisp
(defun sk/toggle-frame-fullscreen-non-native ()
  "Toggle full screen non-natively. Uses the `fullboth' frame paramerter
   rather than `fullscreen'. Useful to fullscreen on OSX w/o animations."
  (interactive)
  (modify-frame-parameters
   nil
   `((maximized
      . ,(unless (memq (frame-parameter nil 'fullscreen) '(fullscreen fullboth))
           (frame-parameter nil 'fullscreen)))
     (fullscreen
      . ,(if (memq (frame-parameter nil 'fullscreen) '(fullscreen fullboth))
             (if (eq (frame-parameter nil 'maximized) 'maximized)
                 'maximized)
           'fullboth)))))
#+END_SRC

**** Key binding

#+BEGIN_SRC emacs-lisp
(general-leader-key "tF" '(sk/toggle-frame-fullscreen-non-native :which-key "toggle fullscreen"))
#+END_SRC
*** Split window and move

I hate the default Emacs behavior of split windows which just splits the window but doesn't go there.

#+BEGIN_SRC emacs-lisp
(defun sk/split-below-and-move ()
  (interactive)
  (split-window-below)
  (other-window 1))
(defun sk/split-right-and-move ()
  (interactive)
  (split-window-right)
  (other-window 1))
#+END_SRC

**** Key binding

This is one of the few occasions I just replace it with my custom function because I use it so much. Since the defaults of [[*Global%20prefixed%20keys][modalka]] and [[*Global%20prefixed%20keys][which-key]] already use and define this binding, there is no need for another one.

#+BEGIN_SRC emacs-lisp
(bind-keys
  ("C-x 2" . sk/split-below-and-move)
  ("C-x 3" . sk/split-right-and-move))
#+END_SRC

*** Turn the adjoining window (only with 2 windows)

#+BEGIN_SRC emacs-lisp
(defun sk/other-window-down ()
  "Scrolls down in adjoining window"
  (interactive)
  (other-window 1)
  (scroll-up-command)
  (other-window 1))
(defun sk/other-window-up ()
  "Scrolls up in adjoining window"
  (interactive)
  (other-window 1)
  (scroll-down-command)
  (other-window 1))
#+END_SRC

**** Key binding

#+BEGIN_SRC emacs-lisp
 (general-leader-key 
  "w]" '(sk/other-window-down :which-key "adjacent pdf next page")
  "w[" '(sk/other-window-up :which-key "adjacent pdf prev page"))
#+END_SRC

*** Smarter start of line

This function, from [[http://emacsredux.com/blog/2013/05/22/smarter-navigation-to-the-beginning-of-a-line/][emacsredux blog]], defines a better start of line and remaps =C-a= for it.

#+BEGIN_SRC emacs-lisp
(defun sk/smarter-move-beginning-of-line (arg)
  "Move point back to indentation of beginning of line.
Move point to the first non-whitespace character on this line.
If point is already there, move to the beginning of the line.
Effectively toggle between the first non-whitespace character and
the beginning of the line.
If ARG is not nil or 1, move forward ARG - 1 lines first.  If
point reaches the beginning or end of the buffer, stop there."
  (interactive "^p")
  (setq arg (or arg 1))
  ;; Move lines first
  (when (/= arg 1)
    (let ((line-move-visual nil))
      (forward-line (1- arg))))
  (let ((orig-point (point)))
    (back-to-indentation)
    (when (= orig-point (point))
      (move-beginning-of-line 1))))
#+END_SRC

**** Key binding

#+BEGIN_SRC emacs-lisp
;; remap C-a to `smarter-move-beginning-of-line'
(global-set-key [remap move-beginning-of-line]
                'sk/smarter-move-beginning-of-line)
#+END_SRC

*** Rotate the windows

[[https://github.com/magnars/.emacs.d/blob/master/defuns/buffer-defuns.el][Stolen]] from Magnar Sveen's configuration. This function is bound to the [[*Window%20navigation][hydra]] defined for window navigation.

#+BEGIN_SRC emacs-lisp
(defun sk/rotate-windows ()
  "Rotate your windows"
  (interactive)
  (cond ((not (> (count-windows)1))
         (message "You can't rotate a single window!"))
        (t
         (setq i 1)
         (setq numWindows (count-windows))
         (while  (< i numWindows)
           (let* (
                  (w1 (elt (window-list) i))
                  (w2 (elt (window-list) (+ (% i numWindows) 1)))

                  (b1 (window-buffer w1))
                  (b2 (window-buffer w2))

                  (s1 (window-start w1))
                  (s2 (window-start w2))
                  )
             (set-window-buffer w1  b2)
             (set-window-buffer w2 b1)
             (set-window-start w1 s2)
             (set-window-start w2 s1)
             (setq i (1+ i)))))))
#+END_SRC
**** Key binding

#+BEGIN_SRC emacs-lisp
 (general-leader-key 
    "wr" '(sk/rotate-windows)
    )
#+END_SRC

*** Open the current HTML file in browser

Not sure where I got this from. Most likely Magnar Sveen.

#+BEGIN_SRC emacs-lisp
(defun sk/browse-current-file ()
  "Open the current file as a URL using `browse-url'."
  (interactive)
  (let ((file-name (buffer-file-name)))
    (if (and (fboundp 'tramp-tramp-file-p)
             (tramp-tramp-file-p file-name))
        (error "Cannot open tramp file")
      (browse-url (concat "file://" file-name)))))
#+END_SRC

**** Key binding

#+BEGIN_SRC emacs-lisp
 (general-leader-key 
    "wB" '(sk/browse-current-file :which-key "browse file in browser")
    )
#+END_SRC
*** Switching Next/Previous User Buffers
#+BEGIN_SRC emacs-lisp
(defun next-user-buffer ()
  "Switch to the next user buffer.
User buffers are those whose name does not start with *."
  (interactive)
  (next-buffer)
  (let ((i 0))
    (while (and (string-match "^*" (buffer-name)) (< i 50))
      (setq i (1+ i)) (next-buffer) )))

(defun previous-user-buffer ()
  "Switch to the previous user buffer.
User buffers are those whose name does not start with *."
  (interactive)
  (previous-buffer)
  (let ((i 0))
    (while (and (string-match "^*" (buffer-name)) (< i 50))
      (setq i (1+ i)) (previous-buffer) )))

(defun next-emacs-buffer ()
  "Switch to the next emacs buffer.
Emacs buffers are those whose name starts with *."
  (interactive)
  (next-buffer)
  (let ((i 0))
    (while (and (not (string-match "^*" (buffer-name))) (< i 50))
      (setq i (1+ i)) (next-buffer) )))

(defun previous-emacs-buffer ()
  "Switch to the previous emacs buffer.
Emacs buffers are those whose name starts with *."
  (interactive)
  (previous-buffer)
  (let ((i 0))
    (while (and (not (string-match "^*" (buffer-name))) (< i 50))
      (setq i (1+ i)) (previous-buffer) )))

  (general-leader-key 
   "bn" '(next-user-buffer :which-key "next buffer")
   "bp" '(previous-user-buffer :which-key "previous buffer")
   "bN" '(next-emacs-buffer)
   "bP" '(previous-emacs-buffer)
   )
#+END_SRC
* Visual

This section adds some packages which enhance visual feedback and mostly work behind the scenes to get stuff done.

** Volatile highlights

I particularly like this [[https://github.com/k-talo/volatile-highlights.el][package]]. It gives visual feedback on some of the common operations like undo, copying and pasting and also inherits the color scheme very well.

#+BEGIN_SRC emacs-lisp
(use-package volatile-highlights
  :ensure t
  :demand t
  :diminish volatile-highlights-mode
  :config
  (volatile-highlights-mode t))
#+END_SRC

** Mode line

[[https://github.com/TheBB/spaceline][Spaceline]] is similar to the [[http://spacemacs.org][Spacemacs]] mode-line. It's pretty cool.

#+BEGIN_SRC emacs-lisp
(use-package spaceline
  :ensure t
  :demand t
  :init
  (setq powerline-default-separator 'arrow-fade)
  :config
  (require 'spaceline-config)
  (spaceline-spacemacs-theme)
  (spaceline-helm-mode))
#+END_SRC
** Origami - folding based on indentation/syntax

Emacs has a built-in =hide-show= mode but it isn't great. [[https://github.com/gregsexton/origami.el][Origami]] improves it a bit.

#+BEGIN_SRC emacs-lisp
(use-package origami
  :ensure t
  :commands (origami-toggle-node)
  :general 
    (general-leader-key
            "x-" '(origami-toggle-node :which-key "syntax-based fold toggle")))
#+END_SRC
** Vimish fold - Fold regions based on selection

Syntax based folding is great and all but sometimes I need to fold some random piece of text and [[https://github.com/mrkkrp/vimish-fold][Vimish fold]] is good for that.

#+BEGIN_SRC emacs-lisp
(use-package vimish-fold
  :ensure t
  :commands (vimish-fold-toggle
             vimish-fold))
#+END_SRC
** dashboard
#+BEGIN_SRC emacs-lisp
(use-package dashboard
  :ensure t
  :config
  (dashboard-setup-startup-hook))
#+END_SRC
* Editing
** Default

Don't use tabs for indent; replace tabs with two spaces.
#+BEGIN_SRC emacs-lisp
(setq-default tab-width 2)
(setq-default indent-tabs-mode nil)
(setq-default js-indent-level 2)
#+END_SRC

newline-and-indent
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "RET") 'newline-and-indent)
#+END_SRC
Delete marked text on typing

#+BEGIN_SRC emacs-lisp
(delete-selection-mode t)
#+END_SRC

Show matching parens

#+BEGIN_SRC emacs-lisp
(show-paren-mode 1)
#+END_SRC

max kill-ring

#+BEGIN_SRC emacs-lisp
(setq kill-ring-max 200)
#+END_SRC
** make-buffer-file-executable
#+BEGIN_SRC emacs-lisp
(add-hook 'after-save-hook 'executable-make-buffer-file-executable-if-script-p)
#+END_SRC
** Commenting

[[https://github.com/remyferre/comment-dwim-2][comment-dwim-2]] improves on the existing =comment-dwim= command for easy commenting. Pretty useful.

#+BEGIN_SRC emacs-lisp
(use-package comment-dwim-2
  :ensure t
  :general 
    (general-leader-key
            "ct" '(comment-dwim-2 :which-key "comment line/region")))
#+END_SRC

** Visual replace

This is the [[https://github.com/benma/visual-regexp.el][good old search and replace]] as opposed to the fancy alternatives such as [[*Interactive edit][iedit]]. You search for a word in the buffer/region, type in the replacement and confirm each one by pressing =y= or =n= or just press =!= to apply this to everything.

#+BEGIN_SRC emacs-lisp
(use-package visual-regexp
  :ensure t
  :commands (vr/query-replace)
  :general 
    (general-leader-key
            "xr" '(vr/query-replace :which-key "replace word/expression"))
  :config
  (use-package visual-regexp-steroids
    :ensure t
    :commands (vr/select-query-replace)))
#+END_SRC
** multiple edit
[[https://github.com/hlissner/evil-multiedit][evil-multiedit]]
#+BEGIN_SRC emacs-lisp
(use-package evil-multiedit
  :ensure t
  :config 
    (evil-multiedit-default-keybinds))
#+END_SRC
** Custom functions
*** Rename the current buffer and the file associated with it

[[https://github.com/magnars/.emacs.d/blob/master/defuns/file-defuns.el][Stolen]] from Magnar Sveen's config.

#+BEGIN_SRC emacs-lisp
(defun sk/rename-current-buffer-file ()
  "Renames current buffer and file it is visiting."
  (interactive)
  (let ((name (buffer-name))
        (filename (buffer-file-name)))
    (if (not (and filename (file-exists-p filename)))
        (error "Buffer '%s' is not visiting a file!" name)
      (let ((new-name (read-file-name "New name: " filename)))
        (if (get-buffer new-name)
            (error "A buffer named '%s' already exists!" new-name)
          (rename-file filename new-name 1)
          (rename-buffer new-name)
          (set-visited-file-name new-name)
          (set-buffer-modified-p nil)
          (message "File '%s' successfully renamed to '%s'"
                   name (file-name-nondirectory new-name)))))))
#+END_SRC

**** Key binding

#+BEGIN_SRC emacs-lisp
(general-leader-key
            "fR" '(sk/rename-current-buffer-file :which-key "rename buffer and file"))
#+END_SRC

*** Delete the current buffer and the file associated with it

[[https://github.com/magnars/.emacs.d/blob/master/defuns/file-defuns.el][Stolen]] from Magnar Sveen's config.

#+BEGIN_SRC emacs-lisp
(defun sk/delete-current-buffer-file ()
  "Removes file connected to current buffer and kills buffer."
  (interactive)
  (let ((filename (buffer-file-name))
        (buffer (current-buffer))
        (name (buffer-name)))
    (if (not (and filename (file-exists-p filename)))
        (ido-kill-buffer)
      (when (yes-or-no-p "Are you sure you want to remove this file? ")
        (delete-file filename)
        (kill-buffer buffer)
        (message "File '%s' successfully removed" filename)))))
#+END_SRC

**** Key binding

#+BEGIN_SRC emacs-lisp
(general-leader-key
            "fD" '(sk/delete-current-buffer-file :which-key "delete buffer and file"))
#+END_SRC
* Project management
** Projectile

[[https://github.com/bbatsov/projectile][Projectile]] is a nice package for project navigation. It hijacks the =C-c p= prefix by default and you can learn more about its commands by pressing =C-c p= and waiting for which key to show hints.

#+BEGIN_SRC emacs-lisp
  (use-package projectile
    :ensure t
    :general 
  (general-leader-key 
  "p!" '(projectile-run-shell-command-in-root)
  "p%" '(projectile-replace-regexp)
  "p&" '(projectile-run-async-shell-command-in-root)
  "pa" '(projectile-toggle-between-implementation-and-test)
  "pb" '(projectile-switch-to-buffer)
  "pc" '(projectile-compile-project)
  "pD" '(projectile-dired)
  "pd" '(projectile-find-dir)
  "pF" '(projectile-find-file-dwim)
  "pf" '(projectile-find-file)
  "/" '(projectile-find-file)
  "pg" '(projectile-find-tag)
  "pI" '(projectile-invalidate-cache)
  "pk" '(projectile-kill-buffers)
  "pp" '(projectile-switch-project)
  "pR" '(projectile-replace)
  "pr" '(projectile-recentf)
  "pT" '(projectile-test-project)
  "pv" '(projectile-vc))
    :init
    (setq projectile-file-exists-remote-cache-expire (* 10 60))
    :diminish projectile-mode
    :config
    (projectile-global-mode))
#+END_SRC

**** Modal binding
Which key modal explanation

#+BEGIN_SRC emacs-lisp
(which-key-add-key-based-replacements
  "SPC d"   "project files"
  "SPC D"   "project switch"
  "SPC TAB" "alternate file")
#+END_SRC

** Ztree

[[https://github.com/fourier/ztree][ztree]] and its function =ztree-diff= is super useful when comparing directory trees.

#+BEGIN_SRC emacs-lisp
(use-package ztree
  :ensure t
  :general 
  (general-leader-key 
  "ft" '(ztree-dir :which-key "tree directory")
  "fT" '(ztree-diff :which-key "diff directories"))
  :init
  (setq ztree-dir-move-focus t))
#+END_SRC
** Neotree

[[https://github.com/jaypei/emacs-neotree][Neotree]] is basically a directory drawer that is popular in all the modern text editors. I use it occasionally.

#+BEGIN_SRC emacs-lisp
(use-package neotree
  :ensure t
  :general 
    (general-leader-key
            "fn" '(neotree-toggle)
            "pt" '(neotree-find-project-root))
  :init
  (setq neo-smart-open t))
#+END_SRC
** Perspective

[[https://github.com/nex3/perspective-el][Perspective]] creates different view ports in Emacs preserving the Window configuration. Super useful.

#+BEGIN_SRC emacs-lisp
(use-package perspective
  :ensure t
  :general 
    (general-leader-key
            "lp" '(persp-switch)
            "lk" '(persp-kill)
            "lb" '(persp-switch-to-buffer)
            "lR" '(persp-rename))
  :config
  (persp-mode 1))
#+END_SRC
* Programming
** Editorconfig

[[http://editorconfig.org][Editorconfig]] is a small utility that is helpful in keeping the code clean as it takes care of the necessary indentation and can be used across editors.

#+BEGIN_SRC emacs-lisp
(use-package editorconfig
  :ensure t
  :demand t
  :config
  (editorconfig-mode 1))
#+END_SRC
** Web
*** Web mode

[[http://web-mode.org][This]] is a fully featured, supposedly awesome, package to edit HTML in Emacs.

#+BEGIN_SRC emacs-lisp
(use-package web-mode
  :ensure t
  :mode ("\\.html$" . web-mode))
#+END_SRC
*** JavaScript syntax highlighting

[[https://github.com/thomblake/js3-mode][This]] improves on the built-in JavaScript syntax highlighting.

#+BEGIN_SRC emacs-lisp
(use-package js2-mode
  :ensure t
  :mode ("\\.js$" . js2-mode))
#+END_SRC
*** SCSS syntax highlighting

Occasionally I'm forced to open SCSS files.

#+BEGIN_SRC emacs-lisp
(use-package scss-mode
  :ensure t
  :mode "\\.scss$")
#+END_SRC
*** JSON mode

Syntax highlighting for =json= files.

#+BEGIN_SRC emacs-lisp
(use-package json-mode
  :ensure t
  :mode "\\.json$")
#+END_SRC
*** Write fast HTML

[[https://github.com/smihica/emmet-mode][Emmet]] is very useful while writing HTML. Look in to the guide for more details as to how to use it.

#+BEGIN_SRC emacs-lisp
(use-package emmet-mode
  :ensure t
  :diminish (emmet-mode . "ε")
  :bind* (("C-)" . emmet-next-edit-point)
          ("C-(" . emmet-prev-edit-point))
  :commands (emmet-mode
             emmet-next-edit-point
             emmet-prev-edit-point))
#+END_SRC
*** JavaScript navigation

[[http://ternjs.net][Tern]] describes itself as a code analysis engine and [[https://github.com/ternjs/tern][this]] is an implementation to bring it into Emacs.

#+BEGIN_SRC emacs-lisp
(use-package tern
  :ensure t
  :diminish tern-mode
  :defer 2
  :config
  (progn
    (setq tern-command (append tern-command '("--no-port-file")))
    (add-hook 'js2-mode-hook '(lambda () (tern-mode t)))))
#+END_SRC
*** Beautify

I'm not sure how useful [[https://github.com/yasuyk/web-beautify][this]] is but just like I have formatters for others, I'm keeping this.

#+BEGIN_SRC emacs-lisp
(use-package web-beautify
  :ensure t
  :commands (web-beautify-css
             web-beautify-css-buffer
             web-beautify-html
             web-beautify-html-buffer
             web-beautify-js
             web-beautify-js-buffer))
#+END_SRC
*** vueify-mmm-mode
#+BEGIN_SRC emacs-lisp
(use-package mmm-mode
  :ensure t
  :config
  (setq mmm-global-mode 'maybe)

  (dolist (langsets '(("script" . ((coffee . coffee-mode)
                                   (es6    . js2-mode)))
                      ("style"  . ((stylus . stylus-mode)
                                   (less   . less-css-mode)
                                   (scss   . scss-mode)))))
    (let ((tag (car langsets)))
      (dolist (pair (cdr langsets))
        (let* ((lang       (car pair))
               (submode    (cdr pair))
               (class-name (make-symbol (format "vueify-%s-%s" tag lang)))
               (front      (format "<%s lang=\"%s\">" tag lang))
               (back       (format "</%s>" tag)))
          (mmm-add-classes
           `((,class-name
              :submode ,submode
              :front ,front
              :back ,back)))
         ;(mmm-add-mode-ext-class nil "\\.vue?\\'" class-name)
          (mmm-add-mode-ext-class nil "\\.vue?\\'" class-name)))))

  (add-to-list 'auto-mode-alist '("\\.vue?\\'" . web-mode))
  (add-to-list 'auto-mode-alist '("\\.we?\\'" . web-mode)))

#+END_SRC
** Error checking

[[http://www.flycheck.org/en/latest/][Flycheck]] is awesome.

#+BEGIN_SRC emacs-lisp
(use-package flycheck
  :ensure t
  :diminish flycheck-mode
  :defer 2
  :general 
    (general-leader-key
            "en" '(flycheck-next-error :which-key "next error")
            "ep" '(flycheck-previous-error :which-key "previous error")
            "el" '(flycheck-list-errors :which-key "list errors"))
  :config
   ;; disable jshint since we prefer eslint checking
  (setq-default flycheck-disabled-checkers
                (append flycheck-disabled-checkers
                        '(javascript-jshint)))
  ;; use eslint with web-mode for jsx files
  (flycheck-add-mode 'javascript-eslint 'web-mode)

  ;; customize flycheck temp file prefix
  (setq-default flycheck-temp-prefix ".flycheck")

  ;; disable json-jsonlist checking for json files
  (setq-default flycheck-disabled-checkers
                (append flycheck-disabled-checkers
                        '(json-jsonlist)))
  (global-flycheck-mode))
#+END_SRC
** Auto completion

[[http://company-mode.github.io][Company mode]] standing for "complete any" is an auto-completion framework with a lot of third part packages and backends. Although I usually trigger manual completion, this is useful to have sometimes. This is a huge definition. Also, this is the one of the functionality I bind to =C-c= and not =M-m=.

#+BEGIN_SRC emacs-lisp
(use-package company
  :ensure t
  :commands (company-mode
             company-complete
             company-complete-common
             company-complete-common-or-cycle
             company-files
             company-dabbrev
             company-ispell
             company-c-headers
             company-jedi
             company-tern
             company-web-html
             company-auctex)
  :init
  (setq company-minimum-prefix-length 2
        company-require-match 0
        company-selection-wrap-around t
        company-dabbrev-downcase nil
        company-tooltip-limit 20                      ; bigger popup window
        company-tooltip-align-annotations 't          ; align annotations to the right tooltip border
        company-idle-delay .4                         ; decrease delay before autocompletion popup shows
        company-begin-commands '(self-insert-command)) ; start autocompletion only after typing
  (eval-after-load 'company
    '(add-to-list 'company-backends '(company-files
                                      company-capf)))
  :bind (("M-t"   . company-complete)
         ;("C-c f" . company-files)
         ;("C-c a" . company-dabbrev)
         ;("C-c d" . company-ispell)
         :map company-active-map
              ("C-n"    . company-select-next)
              ("C-p"    . company-select-previous)
              ([return] . company-complete-selection)
              ("C-w"    . backward-kill-word)
              ("C-c"    . company-abort)
              ("C-c"    . company-search-abort))
  :diminish (company-mode . "ς")
  :config
  (global-company-mode)
  ;; Tern for JS
  (use-package company-tern
    :ensure t
    :general 
    (general-leader-key
     "tp" '(company-tern))
    :init
    (setq company-tern-property-marker "")
    (setq company-tern-meta-as-single-line t)
    :config
    (add-to-list 'company-backends 'company-tern))
  ;; HTML completion
  (use-package company-web
    :ensure t
    :general 
    (general-leader-key
     "tw" '(company-web-html))
    :config
    (add-to-list 'company-backends 'company-web-html))
  )
#+END_SRC
** smartparens
#+BEGIN_SRC emacs-lisp
 (use-package smartparens
   :ensure t
   :init
   (progn
     (require 'smartparens-config)
     (defun sp-pair-on-newline (id action context)
       "Put trailing pair on newline and return to point."
       (save-excursion
         (newline)
         (indent-according-to-mode)))
 
     (defun sp-pair-on-newline-and-indent (id action context)
       "Open a new brace or bracket expression, with relevant newlines and indent. "
       (sp-pair-on-newline id action context)
       (indent-according-to-mode))
 
     (sp-pair "{" nil :post-handlers
              '(:add ((lambda (id action context)
                        (sp-pair-on-newline-and-indent id action context)) "RET")))
     (sp-pair "[" nil :post-handlers
              '(:add ((lambda (id action context)
                        (sp-pair-on-newline-and-indent id action context)) "RET")))
 
     (sp-local-pair '(markdown-mode gfm-mode) "*" "*"
                    :unless '(sp-in-string-p)
                    :actions '(insert wrap))
 
     (smartparens-global-mode t)
     (setq sp-highlight-pair-overlay nil)
))

#+END_SRC
** Document
** Code Folding
** Jump to Definition
* Org-mode
  #+BEGIN_SRC emacs-lisp
    (org-babel-load-file (concat emacs-base-dir "org-mode.org"))
    (setq org-file-apps org-file-apps-defaults-macosx)
    (setq org-src-tab-acts-natively t)
    (use-package htmlize :ensure t)
  #+END_SRC
** cal-china-x
#+BEGIN_SRC emacs-lisp
(use-package cal-china-x
  :ensure t
  :init
    (setq mark-holidays-in-calendar t)
  :config
    (setq cal-china-x-important-holidays cal-china-x-chinese-holidays)
    (setq calendar-holidays cal-china-x-important-holidays))
#+END_SRC
** org-download
#+BEGIN_SRC emacs-lisp
(use-package org-download
  :ensure t
  :init 
  (progn
  (setq-default org-download-image-dir "~/personal/org/img")
  (org-download-enable)
    ))
#+END_SRC
** key bindings
#+BEGIN_SRC emacs-lisp
  (general-leader-key 
   "oa" '(org-agenda)
   "ob" '(org-iswitchb)
   "oc" '(org-capture))
   
#+END_SRC
* Version control
** Magit

[[https://magit.vc][The best interface to Git ever]]. Enough said.

#+BEGIN_SRC emacs-lisp
(use-package magit
  :ensure t
  :general 
    (general-leader-key
            "vgs" '(magit-status)
            "vgb" '(magit-blame)
            "vgm" '(magit-dispatch-popup)
            "vgS" '(magit-stage-file)
            "vgU" '(magit-unstage-file)
            ))
#+END_SRC
** Highlight diffs

[[https://github.com/dgutov/diff-hl][Highlight git diffs on the fly]].

#+BEGIN_SRC emacs-lisp
(use-package diff-hl
  :ensure t
  :commands (global-diff-hl-mode
             diff-hl-mode
             diff-hl-next-hunk
             diff-hl-previous-hunk
             diff-hl-mark-hunk
             diff-hl-diff-goto-hunk
             diff-hl-revert-hunk)
  :general 
    (general-leader-key
            "v]" '(diff-hl-next-hunk)
            "v[" '(diff-hl-previous-hunk)
            "vm" '(diff-hl-mark-hunk)
            "vh" '(diff-hl-diff-goto-hunk)
            "vH" '(diff-hl-revert-hunk))
  :config
  (global-diff-hl-mode)
  (diff-hl-flydiff-mode)
  (diff-hl-margin-mode)
  (diff-hl-dired-mode))
#+END_SRC
** Git time machine

The ability to move to past versions of the current file, [[https://github.com/pidu/git-timemachine][like a time machine]].

#+BEGIN_SRC emacs-lisp
(use-package git-timemachine
  :ensure t
  :commands (git-timemachine-toggle
             git-timemachine-switch-branch)
  :general 
    (general-leader-key
            "vgl" '(git-timemachine-toggle)
            "vgL" '(git-timemachine-switch-branch)
            ))
#+END_SRC
** Browse remote files

[[https://github.com/rmuslimov/browse-at-remote][browse-at-remote]] is a very handy package to view the file/region on the actual Github/Gitlab/Bitbucket page.

#+BEGIN_SRC emacs-lisp
(use-package browse-at-remote
  :ensure t
  :general 
    (general-leader-key
            "vr" '(browse-at-remote)))
#+END_SRC
** =ediff=

[[https://www.gnu.org/software/emacs/manual/html_node/ediff/][Ediff mode]] is a UNIX patching tool and my version controlling package uses this to help resolve merge conflicts and having some better defaults will be useful for this.

#+BEGIN_SRC emacs-lisp
(setq ediff-window-setup-function 'ediff-setup-windows-plain
      ediff-split-window-function 'split-window-horizontally)
#+END_SRC

* Integration
** Console
** Operating System
*** Add a package to set the correct path

Sometimes when opening the Mac Emacs.app via GUI, by clicking the button, it doesn't load all the proper utilities from the OS. This package fixes that.

#+BEGIN_SRC emacs-lisp
(use-package exec-path-from-shell
  :ensure t
  :demand t
  :init
  (setq exec-path-from-shell-check-startup-files nil)
  :config
  ;; (exec-path-from-shell-copy-env "PYTHONPATH")
  (when (memq window-system '(mac ns x))
    (exec-path-from-shell-initialize)))
#+END_SRC

** Search
*** wgrep

Writable grep/ack/ag/pt buffer and apply the changes to files.

#+BEGIN_SRC emacs-lisp
(use-package wgrep
  :ensure t
  :config
  (setq wgrep-enable-key "r"))

#+END_SRC
** Reveal
#+BEGIN_SRC emacs-lisp
  (use-package ox-reveal
    :ensure t
    :init
      (setq org-reveal-root "file:///Users/eshion/emacs.d/lib/reveal.js/")
      ;(setq org-reveal-root "http://cdn.bootcss.com/reveal.js/3.3.0/")
      (setq org-reveal-hlevel 2))
#+END_SRC
** Dictionary
[[https://github.com/xuchunyang/youdao-dictionary.el][youdao-dictionary]]
#+BEGIN_SRC emacs-lisp
(use-package youdao-dictionary
  :ensure t
  :init
  (setq url-automatic-caching t)
  :general 
  (general-leader-key
          "xyS" '(youdao-dictionary-search-at-point :which-key "youdao dictionary")
          "xys" '(youdao-dictionary-search-at-point+ :which-key "youdao dictionary popup")))
#+END_SRC

* Internet
** Browser
** Mail
** gnus
#+BEGIN_SRC emacs-lisp
(defun my-gnus-group-list-subscribed-groups ()
  "List all subscribed groups with or without un-read messages"
  (interactive)
  (gnus-group-list-all-groups 5)
  )

(add-hook 'gnus-group-mode-hook
          ;; list all the subscribed groups even they contain zero un-read messages
          (lambda () (local-set-key "o" 'my-gnus-group-list-subscribed-groups ))
          )

(setq-default
  gnus-summary-line-format "%U%R%z %(%&user-date;  %-15,15f  %B%s%)\n"
  gnus-user-date-format-alist '((t . "%Y-%m-%d %H:%M"))
  gnus-summary-thread-gathering-function 'gnus-gather-threads-by-references
  gnus-sum-thread-tree-false-root ""
  gnus-sum-thread-tree-indent " "
  gnus-sum-thread-tree-leaf-with-other "├► "
  gnus-sum-thread-tree-root ""
  gnus-sum-thread-tree-single-leaf "╰► "
  gnus-sum-thread-tree-vertical "│")
(setq gnus-thread-sort-functions
      '(
        (not gnus-thread-sort-by-date)
        (not gnus-thread-sort-by-number)
        ))

;(setq message-send-mail-function 'smtpmail-send-it
;      smtpmail-starttls-credentials '(("smtp.gmail.com" 587 nil nil))
;      smtpmail-auth-credentials "~/.authinfo.gpg"
;      smtpmail-default-smtp-server "smtp.gmail.com"
;      smtpmail-smtp-server "smtp.gmail.com"
;      smtpmail-smtp-service 587
;      smtpmail-local-domain "localhost")


;; Fetch only part of the article if we can.  I saw this in someone
;; else's .gnus
(setq gnus-read-active-file 'some)

;; Tree view for groups.  I like the organisational feel this has.
;(add-hook 'gnus-group-mode-hook 'gnus-topic-mode)

;; Threads!  I hate reading un-threaded email -- especially mailing
;; lists.  This helps a ton!
(setq gnus-summary-thread-gathering-function
      'gnus-gather-threads-by-subject)

;; Also, I prefer to see only the top level message.  If a message has
;; several replies or is part of a thread, only show the first
;; message.  'gnus-thread-ignore-subject' will ignore the subject and
;; look at 'In-Reply-To:' and 'References:' headers.
(setq gnus-thread-hide-subtree t)
(setq gnus-thread-ignore-subject t)

;(setq mm-text-html-renderer 'eww)

;stop ask me "how many articles from" and
;show-me-all-my-mail-all-ways.
;(setq gnus-large-newsgroup 'nil)

(defun message-select-forwarded-email-tags ()
  "select the <#mml-or-what-ever> tags in message-mode"
  (interactive)
  (let (start rlt)
    (when (search-forward "<#")
      (setq start (point))
      (push-mark (point) t t)
      (goto-char (point-max))
      (search-backward ">")
      (forward-char)
      (setq rlt t))
    rlt))

(defun message-copy-select-forwarded-email-tags ()
  "copy the <#mml-or-what-ever> tags in message-mode"
  (interactive)
  (save-excursion
    (cond
     ((message-select-forwarded-email-tags)
      (copy-region-as-kill (region-beginning) (region-end))
      (message "forwarded email tags copied!"))
     (t (message "NO forwarded email tags found!"))
     )
    ))

#+END_SRC
** bbdb
#+BEGIN_SRC emacs-lisp
(use-package bbdb
  :config

  (use-package gnus
    :ensure nil)

  (use-package message
    :ensure nil)

  (use-package bbdb-gnus
    :ensure bbdb
    :config
    (defun eh-bbdb-insinuate-gnus ()
      "BBDB setting for gnus, See `bbdb-insinuate-gnus' for details."
      (define-key gnus-summary-mode-map ":" 'bbdb-mua-display-sender)
      (define-key gnus-article-mode-map ":" 'bbdb-mua-display-sender)
      (define-key gnus-summary-mode-map ";" 'bbdb-mua-edit-field)
      (define-key gnus-article-mode-map ";" 'bbdb-mua-edit-field))

    (add-hook 'gnus-startup-hook 'eh-bbdb-insinuate-gnus))

;  (use-package bbdb-vcard)
;  (use-package bbdb-csv-import)

;  (use-package bbdb-android
;    :config
;    (defun eh-bbdb-keybinding ()
;      (bbdb-handy-keybinding-setup)
;      (define-key bbdb-mode-map "c" 'eh-bbdb-create)
;      (define-key bbdb-mode-map "M" 'bbdb-merge-records)
;      (define-key bbdb-mode-map (kbd "x e") 'bbdb-android-export)
;      (define-key bbdb-mode-map (kbd "x i") 'bbdb-android-import)
;      (define-key bbdb-mode-map (kbd "x r") 'bbdb-android-import-from-radicale))
;    (add-hook 'bbdb-mode-hook 'eh-bbdb-keybinding))

  (use-package bbdb-handy
    :config
    (define-key message-mode-map "\C-cb" 'bbdb-handy)
    (define-key message-mode-map "\t" 'bbdb-handy-message-tab))

  (setq bbdb-file "~/contacts/contacts.bbdb"
        bbdb-phone-style nil
        bbdb-pop-up-window-size 0.3
        bbdb-mua-pop-up-window-size 1.0
        bbdb-mua-update-interactive-p '(query . create)  ;; Invoking bbdb interactively
        bbdb-message-all-addresses t
        bbdb-mua-summary-mark nil
        bbdb-completion-list t
        bbdb-complete-mail-allow-cycling t
        bbdb-layout 'multi-line
        bbdb-pop-up-layout 'multi-line
        bbdb-mua-pop-up nil
        bbdb-default-country "China"
        bbdb-dial-function 'bbdb-android-dia-with-adb)

  (setq bbdb-vcard-name-imported-priority '(formated-name first-last bbdb-vcard-generate-bbdb-name)
        bbdb-vcard-skip-on-import '("^X-GSM-" "^X-RADICALE-" "^X-CONTACTSYNC-" "^PRODID" "^UID")
        bbdb-vcard-import-translation-table '(("CELL\\|CAR" . "cell")
                                              ("WORK\\|pref" . "work")
                                              ("DOM\\|HOME" . "home")))

  ;; initialization
  ;; (bbdb-initialize 'gnus 'message)
  ;; (bbdb-mua-auto-update-init 'gnus 'message)
  (bbdb-initialize)

  ;; Push email to message-mode
  (defun eh-bbdb-create ()
    (interactive)
    (let ((name (bbdb-read-string "联系人名称: "))
          (mail (bbdb-split 'mail (bbdb-read-string "电子邮件: ")))
          (phone (list (vector "work" (bbdb-read-string "电话号码: ")))))
      (bbdb-create-internal name nil nil nil mail phone)
      (bbdb name))))
#+END_SRC

** IRC
** Chat
** Social Network
** Web Feed
* DevOps
* Package Management
** Package Manager
** Package Configuration
** Package Updates
* Appearance
** Diminish minor modes from the mode line

Now that we have made sure we have installed use-package, we will make sure another nice package to change the [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Mode-Line-Variables.html][mode-line minor mode list]]. For this, we can use use-package itself and also go ahead and diminish some built-in minor modes.

#+BEGIN_SRC emacs-lisp
(use-package diminish
  :ensure t
  :demand t
  :diminish (visual-line-mode . "ω")
  :diminish hs-minor-mode
  :diminish abbrev-mode
  :diminish auto-fill-function
  :diminish subword-mode)
#+END_SRC

However, some built-in minor modes are notorious and don't seem to work with the above method. Let's diminish them using functions one by one.

*** Diminish =org-indent= mode

I like to enable the [[http://orgmode.org/manual/Clean-view.html][org-indent mode]] for a clean view in Org mode and this doesn't seem to get diminish the usual way. We define a function and a add a hook to achieve this.

#+BEGIN_SRC emacs-lisp
(defun sk/diminish-org-indent ()
  (interactive)
  (diminish 'org-indent-mode ""))
(add-hook 'org-indent-mode-hook 'sk/diminish-org-indent)
#+END_SRC

*** Diminish =auto-revert= mode

[[https://www.gnu.org/software/emacs/manual/html_node/emacs/Reverting.html][auto-revert mode]] is useful when Emacs auto-saves your file and you want to load the backup.

#+BEGIN_SRC emacs-lisp
(defun sk/diminish-auto-revert ()
  (interactive)
  (diminish 'auto-revert-mode ""))
(add-hook 'auto-revert-mode-hook 'sk/diminish-auto-revert)
#+END_SRC

*** Diminish =eldoc= mode

Eldoc mode is a mode to display documentation for languages in Emacs

#+BEGIN_SRC emacs-lisp
(defun sk/diminish-eldoc ()
  (interactive)
  (diminish 'eldoc-mode ""))
(add-hook 'eldoc-mode-hook 'sk/diminish-eldoc)
#+END_SRC

*** Diminish =subword= mode

=subword-mode= is described [[*Move%20correctly%20over%20camelCased%20words][here]].

#+BEGIN_SRC emacs-lisp
(defun sk/diminish-subword ()
  (interactive)
  (diminish 'subword-mode ""))
(add-hook 'subword-mode-hook 'sk/diminish-subword)
#+END_SRC
** adjust-opacity
#+BEGIN_SRC emacs-lisp
(defun adjust-opacity (frame incr)
  (let* ((oldalpha (or (frame-parameter frame 'alpha) 100))
         (newalpha (+ incr oldalpha)))
    (when (and (<= frame-alpha-lower-limit newalpha) (>= 100 newalpha))
      (modify-frame-parameters frame (list (cons 'alpha newalpha))))))
(global-set-key (kbd "M-C-8") '(lambda () (interactive) (adjust-opacity nil -5)))
(global-set-key (kbd "M-C-9") '(lambda () (interactive) (adjust-opacity nil 5)))
(global-set-key (kbd "M-C-0") '(lambda () (interactive) (modify-frame-parameters nil `((alpha . 100)))))
#+END_SRC
*** Hydra

A hydra for adjust opacity!

#+BEGIN_SRC emacs-lisp
(defhydra es/hydra-adjust-opacity (:color blue
                           :hint nil)
  "
 _+_: increase opacity    _-_: decrease opacity    _=_: restore opacity   _q_: quit
 "
  ("+" (lambda () (interactive) (adjust-opacity nil 5)))
  ("-" (lambda () (interactive) (adjust-opacity nil -5)))
  ("=" (lambda () (interactive) (modify-frame-parameters nil `((alpha . 100)))))
  ("q" nil :color blue))
#+END_SRC

*** Key binding

#+BEGIN_SRC emacs-lisp
  (general-leader-key 
  "zo" '(es/hydra-adjust-opacity/body :which-key "adjust opacity")
   )
#+END_SRC

** indent-guide
#+BEGIN_SRC emacs-lisp
  (use-package indent-guide
    :ensure t
    :config 
      (indent-guide-global-mode))
#+END_SRC
* Theme
#+BEGIN_SRC emacs-lisp
(use-package atom-one-dark-theme
  :ensure t
  :config (load-theme 'atom-one-dark t))
#+END_SRC
* Multimedia
* Fun
** Weather

And while we are it, why not go ahead and [[https://github.com/bcbcarl/emacs-wttrin][get some weather status too]].

#+BEGIN_SRC emacs-lisp
(use-package wttrin
  :ensure t
  :commands (wttrin)
  :init
  (setq wttrin-default-cities '("Shenzhen")))
#+END_SRC

* Key bindings
** which key group describe
#+BEGIN_SRC emacs-lisp
(general-leader-key 
 "a" '(:ignore t :which-key "applications")
 "B" '(:ignore t :which-key "global-buffers")
 "b" '(:ignore t :which-key "buffers")
 "c" '(:ignore t :which-key "compile/comments")
 "e" '(:ignore t :which-key "errors")
 "f" '(:ignore t :which-key "files")
 "fC" '(:ignore t :which-key "files/convert")
 "fe" '(:ignore t :which-key "emacs")
 "fv" '(:ignore t :which-key "variables")
 "h" '(:ignore t :which-key "help")
 "hd" '(:ignore t :which-key "help-describe")
 "i" '(:ignore t :which-key "insertion")
 "j" '(:ignore t :which-key "jump/join/split")
 "k" '(:ignore t :which-key "lisp")
 "l" '(:ignore t :which-key "layer/workspace")
 "n" '(:ignore t :which-key "narrow/numbers")
 "o" '(:ignore t :which-key "org")
 "p" '(:ignore t :which-key "projects")
 "q" '(:ignore t :which-key "quit")
 "r" '(:ignore t :which-key "registers/rings/resume")
 "s" '(:ignore t :which-key "search/symbol")
 "sa" '(:ignore t :which-key "ag")
 "sg" '(:ignore t :which-key "grep")
 "sk" '(:ignore t :which-key "ack")
 "st" '(:ignore t :which-key "pt")
 "T" '(:ignore t :which-key "UI toggles/themes")
 "t" '(:ignore t :which-key "toggles")
 "tC" '(:ignore t :which-key "colors")
 "tE" '(:ignore t :which-key "editing-styles")
 "th" '(:ignore t :which-key "highlight")
 "tm" '(:ignore t :which-key "modeline")
 "v" '(:ignore t :which-key "version-control")
 "vg" '(:ignore t :which-key "magit")
 "w" '(:ignore t :which-key "windows")
 "wp" '(:ignore t :which-key "popup")
 "x" '(:ignore t :which-key "text")
 "xa" '(:ignore t :which-key "align")
 "xd" '(:ignore t :which-key "delete")
 "xj" '(:ignore t :which-key "justification")
 "xl" '(:ignore t :which-key "lines")
 "xr" '(:ignore t :which-key "regular expressions")
 "xt" '(:ignore t :which-key "transpos")
 "xw" '(:ignore t :which-key "words")
 "xy" '(:ignore t :which-key "youdu-translate")
 "z" '(:ignore t :which-key "zoom")
 "" '(:ignore t :which-key "leader"))
#+END_SRC
** global
#+BEGIN_SRC emacs-lisp
  (general-leader-key 
   "SPC" (general-simulate-keys "M-x" t "M-x" M-x)
   )
#+END_SRC
** applications
#+BEGIN_SRC emacs-lisp
  (general-leader-key 
   "ad" '(dired)
   "ag" '(gnus)
   "ap" '(proced)
   "al" '(list-processces)
   "au" '(undo-tree-visualize)
   "aw" '(wttrin :which-key "Weather")
   )
#+END_SRC
** buffers
#+BEGIN_SRC emacs-lisp
  (general-leader-key 
   ;"bn" '(next-buffer)
   ;"bp" '(previous-buffer)
   "bw" '(read-only-mode)
   )
#+END_SRC
** compile/comments
#+BEGIN_SRC emacs-lisp
  (general-leader-key 
   "cC" '(compile)
   "ch" '(hide/show-comments-toggle)
   "ck" '(kill-compilation)
   "cr" '(recompile)
   )
#+END_SRC
** files
#+BEGIN_SRC emacs-lisp
  (general-leader-key 
   "fb" '(bookmark-jump)
   "fc" '(copy-file)
   "ff" '(find-file)
   "fg" '(rgrep)
   "fj" '(dired-jump)
   "fl" '(find-file-literally)
   "fr" '(find-file-literally)
   "fS" '(evil-write-all)
   "fs" '(save-buffer)
   )
#+END_SRC
*** files/convert
 #+BEGIN_SRC emacs-lisp :tangle no
 (general-leader-key 
    "fd" '(unix2dos)
    "fu" '(dos2unix)
    )
 #+END_SRC
*** emacs
 #+BEGIN_SRC emacs-lisp :tangle no
   (general-leader-key 
    "f" '()
    )
 #+END_SRC
*** variables
 #+BEGIN_SRC emacs-lisp :tangle no
   (general-leader-key 
    "f" '()
    )
 #+END_SRC
** help
#+BEGIN_SRC emacs-lisp
  (general-leader-key 
  "hn" '(view-emacs-news)
  "hw" '(which-key-show-top-level)
   )
#+END_SRC
*** help-describe
 #+BEGIN_SRC emacs-lisp
 (general-leader-key 
    "hb" '(describe-bindings)
    "hc" '(describe-char)
    "hf" '(describe-function)
    "hK" '(describe-keymap)
    "hk" '(describe-key)
    "hp" '(describe-package)
    "ht" '(describe-theme)
    "hv" '(describe-variable)
    )
 #+END_SRC
** insertion
#+BEGIN_SRC emacs-lisp :tangle no
#+END_SRC
** jump/join/split
#+BEGIN_SRC emacs-lisp
  (general-leader-key 
  "jD" '(dired-jump-other-window)
  "jd" '(dired-jump)
  "jf" '(find-function)
  "jI" '(lambda)
  "ji" '(counsel-imenu)
  "jn" '(sp-newline)
  "jo" '(open-line)
  "jq" '(dumb-jump-quick-look)
  "js" '(sp-split-sexp)
  "jv" '(find-variable)
   )
#+END_SRC
** narrow/numbers
#+BEGIN_SRC emacs-lisp
  (general-leader-key 
  "nf" '(narrow-to-defun)
  "np" '(narrow-to-page)
  "nr" '(narrow-to-region)
  "nw" '(widen)
   )
#+END_SRC
** search/symbol
#+BEGIN_SRC emacs-lisp
  (general-leader-key 
   "sb" '(swiper-all)
   "ss" '(swiper)
   )
#+END_SRC
*** ag
 #+BEGIN_SRC emacs-lisp :tangle no
 (general-leader-key 
    "sa" '()
    )
 #+END_SRC
*** grep
 #+BEGIN_SRC emacs-lisp :tangle no
   (general-leader-key 
    "sg" '()
    )
 #+END_SRC
*** ack
 #+BEGIN_SRC emacs-lisp :tangle no
   (general-leader-key 
    "sk" '()
    )
 #+END_SRC
*** pt
 #+BEGIN_SRC emacs-lisp :tangle no
   (general-leader-key 
    "st" '()
    )
 #+END_SRC
** toggles
#+BEGIN_SRC emacs-lisp
  (general-leader-key 
  "tn" '(linum-mode :which-key "line number")
  "tv" '(visual-line-mode)
  "ta" '(company-mode)
  "ti" '(indent-guide-global-mode)
  "to" '(global-origami-mode)
  "tk" '(which-key-mode)
  "ts" '(smartparens-strict-mode)
  "te" '(emmet-mode)
  "tc" '(global-flycheck-mode)
  "tt" '(toggle-truncate-lines :which-key "truncate lines")
   )
#+END_SRC
*** colors
 #+BEGIN_SRC emacs-lisp
 (general-leader-key 
    "tCd" '(rainbow-delimiters-mode)
    "tCp" '(highlight-parentheses-mode)
    )
 #+END_SRC
*** editing-styles
 #+BEGIN_SRC emacs-lisp :tangle no
   (general-leader-key 
    "tE" '()
    )
 #+END_SRC
*** highlight
 #+BEGIN_SRC emacs-lisp :tangle no
   (general-leader-key 
    "th" '()
    )
 #+END_SRC
*** modeline
 #+BEGIN_SRC emacs-lisp :tangle no
   (general-leader-key 
    "tm" '()
    )
 #+END_SRC
** windows
#+BEGIN_SRC emacs-lisp
  (general-leader-key 
   "w-" '(sk/split-below-and-move)
   "w|" '(sk/split-right-and-move)
   "w=" '(balance-windows)
   "wF" '(make-frame)
   "wf" '(follow-mode)
   "wH" '(evil-window-move-far-left)
   "wh" '(evil-window-left)
   "wJ" '(evil-window-move-very-bottom)
   "wj" '(evil-window-down)
   "wK" '(evil-window-move-very-top)
   "wk" '(evil-window-up)
   "wL" '(evil-window-move-far-right)
   "wl" '(evil-window-right)
   "w<down>" '(evil-window-down)
   "w<left>" '(evil-window-left)
   "w<right>" '(evil-window-right)
   "w<up>" '(evil-window-up)
   "w<S-down>" '(evil-window-move-very-bottom)
   "w<S-left>" '(evil-window-move-far-left)
   "w<S-right>" '(evil-window-move-far-right)
   "w<S-up>" '(evil-window-move-very-top)
   "wo" '(other-frame)
   "wS" '(split-window-below-and-focus)
   "ws" '(split-window-below)
   "wU" '(winner-redo)
   "wu" '(winner-undo)
   "wV" '(split-window-right-and-focus)
   "wv" '(split-window-right)
   "ww" '(other-window)
   )
#+END_SRC
** text
#+BEGIN_SRC emacs-lisp
  (general-leader-key 
   "x<TAB>" '(indent-rigidly)
   "xc" '(count-region)
   "xU" '(upcase-region)
   "xu" '(downcase-region)
   )
#+END_SRC
*** align
 #+BEGIN_SRC emacs-lisp
 (general-leader-key 
    "xaa" '(align)
    "xac" '(align-current)
    )
 #+END_SRC
*** delete
 #+BEGIN_SRC emacs-lisp
 (general-leader-key 
    "xdw" '(delete-whitespace-rectangle)
    )
 #+END_SRC
*** justification
 #+BEGIN_SRC emacs-lisp
 (general-leader-key 
    "xjc" '(set-justification-center)
    "xjf" '(set-justification-full)
    "xjl" '(set-justification-left)
    "xjn" '(set-justification-none)
    "xjr" '(set-justification-right)
    )
 #+END_SRC
*** transpos
 #+BEGIN_SRC emacs-lisp
 (general-leader-key 
    "xtc" '(transpos-chars)
    "xtl" '(transpos-lines)
    "xtw" '(transpos-words)
    )
 #+END_SRC
*** words
 #+BEGIN_SRC emacs-lisp
 (general-leader-key 
    "xwd" '(defind-word-at-point)
    )
 #+END_SRC
* Load Customize
#+BEGIN_SRC emacs-lisp
(load custom-file 'noerror)
#+END_SRC
