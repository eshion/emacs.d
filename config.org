* Base
** Load path etc.
#+BEGIN_SRC emacs-lisp
(let ((elisp-dir (expand-file-name "src" emacs-base-dir)))
  ;; add the src directory to the load path
  (add-to-list 'load-path elisp-dir)
  ;; load specific files
  (when (file-exists-p elisp-dir)
    (let ((default-directory elisp-dir))
      (normal-top-level-add-subdirs-to-load-path))))
(setq autoload-file (concat emacs-base-dir "loaddefs.el"))
(setq package-user-dir (concat emacs-base-dir "elpa"))
(setq custom-file (concat emacs-base-dir "custom.el"))
#+END_SRC
* Library
** Add some useful libraries

[[https://github.com/jwiegley/emacs-async][async]], [[https://github.com/magnars/s.el][s]], [[https://github.com/magnars/dash.el][dash]], and [[http://elpa.gnu.org/packages/cl-lib.html][cl-lib]] are libraries for asynchronous processing, string manipulation, list manipulation and backward compatibility respectively.

#+BEGIN_SRC emacs-lisp
(use-package async
  :ensure t
  :commands (async-start))

(use-package cl-lib
  :ensure t)

(use-package dash
  :ensure t)

(use-package s
  :ensure t)
#+END_SRC

* Defaults
** Startup
*** Disabling some GUI elements
#+BEGIN_SRC emacs-lisp
  (when window-system
    (tool-bar-mode 0)
    (scroll-bar-mode 0)
    (menu-bar-mode 1)
    (tooltip-mode 0))
#+END_SRC

*** Set the initial frame size

Frames in Emacs parlance are the equivalent of windows in normal usage. So, when you open Emacs, it opens a /frame/ and not a window. Windows are the what splits are referred to. For further reference [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Frames.html][look it up in the Emacs manual]].

#+BEGIN_SRC emacs-lisp
;; initial window
(setq initial-frame-alist
      '((width . 102)   ; characters in a line
        (height . 54))) ; number of lines

;; sebsequent frame
(setq default-frame-alist
      '((width . 100)   ; characters in a line
        (height . 52))) ; number of lines
#+END_SRC

*** Set the cursor shape

Since I use a modal configuration, it is so easy to detect modes by just changing the cursor shape. Also, the "bar" cursor feels more natural because that's what most application outside of Emacs use anyway. Also, while I'm at it, I don't want the cursor to blink either.

#+BEGIN_SRC emacs-lisp
;; Bar cursor
(setq-default cursor-type '(bar . 1))
;; Don't blink the cursor
(blink-cursor-mode -1)
#+END_SRC

*** Initial screen

The default screen of Emacs is just so useless and cluttered with links and text and help pages. I just need a simple start screen which gently reminds me some things that are important while staying out of the most of the time. This is also called the *scratch* buffer.

#+BEGIN_SRC emacs-lisp
;; No welcome screen - opens directly in scratch buffer
(setq inhibit-startup-message t
      ;initial-scratch-message ""
      initial-major-mode 'fundamental-mode
      inhibit-splash-screen t)
#+END_SRC

*** Startup echo message

There is a small advert for GNU that is displayed in the mini-buffer during startup and, of course, [[http://emacs.stackexchange.com/questions/432/how-to-change-default-minibuffer-message][there is a way to change it]].

#+BEGIN_SRC emacs-lisp
;; Change the echo message
(defun display-startup-echo-area-message ()
  (message "Let the games begin!"))
#+END_SRC
*** Frame title format
#+BEGIN_SRC emacs-lisp
(setq frame-title-format
      '((:eval (if (buffer-file-name)
                   (abbreviate-file-name (buffer-file-name))
                 "%b"))))
#+END_SRC

** Backups
#+BEGIN_SRC emacs-lisp
(setq backup-directory-alist
      `((".*" . ,temporary-file-directory)))
;;varsion control
(setq version-control 1)
(setq kept-old-versions 2)
(setq kept-new-versions 5)
(setq delete-old-versions t)
(setq make-backup-files nil)
(setq backup-by-copying t)
#+END_SRC
** Auto saving

I make sure Emacs auto-saves often but the result is that it messes up my file tree. So, let's ask Emacs to store its backups in some temporary directory.

#+BEGIN_SRC emacs-lisp
(setq auto-save-file-name-transforms
      `((".*" ,temporary-file-directory t)) create-lockfiles nil)
#+END_SRC
** SavePlace
When you visit a file, point goes to the last place where it was when you previously visited the same file.
#+BEGIN_SRC emacs-lisp
(save-place-mode 1)
#+END_SRC
** File encoding system

UTF-8 works for most of the files I tend to use

#+BEGIN_SRC emacs-lisp
(prefer-coding-system 'utf-8)
(setq-default buffer-file-coding-system 'utf-8-auto-unix)
#+END_SRC

** Error message

Mac has an [[http://stuff-things.net/2015/10/05/emacs-visible-bell-work-around-on-os-x-el-capitan/][annoying bug]] when visibly warning you about errors. I hate it. And while we're at it, let's ask Emacs to ignore the audible warning too.

#+BEGIN_SRC emacs-lisp
(setq visible-bell nil)
(setq ring-bell-function 'ignore)
#+END_SRC

** Truncating lines

Emacs has an option to [[https://www.emacswiki.org/emacs/TruncateLines][wrap lines]] which is disabled by default. What this means is that, if the text goes beyond the screen, it will wrap it so that you can see all the text. However, it wraps it with these weird indicators that I find more annoying. Plus, I make sure my code stays within 100 characters always and prefer the soft line wrap while writing prose. Let's make sure it doesn't wrap again.

#+BEGIN_SRC emacs-lisp
(setq-default truncate-lines t)
#+END_SRC

** Large file warning

Whenever, a large file (by Emacs standards) is opened, it asks for confirmation whether we really want to open it but the problem is the limit for this file is set pretty low. Let's increase it a bit so that it doesn't prompt so often.

#+BEGIN_SRC emacs-lisp
(setq large-file-warning-threshold (* 15 1024 1024))
#+END_SRC

** Lazier prompting

While we are in the topic of prompting, a lot of the default prompts ask for a =yes= or a =no=. I'm lazy and so I don't want to type the full words. Let's just make it accept =y= or =n=.

#+BEGIN_SRC emacs-lisp
(fset 'yes-or-no-p 'y-or-n-p)
#+END_SRC

** Expand some words and auto-correct

=abbrev-mode= or abbreviation mode is a built-in mode that auto-corrects the word you mistype on pressing space. For how I practically use it, see [[*Add for auto correction][the auto-correction section]].

#+BEGIN_SRC emacs-lisp
(setq save-abbrevs 'silently)
(setq-default abbrev-mode t)
#+END_SRC

** =gdb=

[[https://www.gnu.org/software/gdb/][gdb]] is the GNU debugger which is used to debug programs. Let's make it multi-windowed like all the other debuggers out there.

#+BEGIN_SRC emacs-lisp
(setq gdb-many-windows t
      gdb-show-main t)
#+END_SRC

** =tramp=

[[https://www.emacswiki.org/emacs/TrampMode][Tramp]] lets you edit files remotely from your local Emacs which is useful because it lets you have all the default configuration. Let's make sure the default protocol is =ssh=.

#+BEGIN_SRC emacs-lisp
(setq tramp-default-method "ssh"
      tramp-backup-directory-alist backup-directory-alist
      tramp-ssh-controlmaster-options "ssh")
#+END_SRC

** Move correctly over camelCased words

=subword-mode= is a built-in mode that helps moving over camelCase words correctly.

#+BEGIN_SRC emacs-lisp
(subword-mode)
#+END_SRC

** Understand the more common =sentence=

By default, Emacs thinks a sentence is a full-stop followed by 2 spaces. Let's make it full-stop and 1 space.

#+BEGIN_SRC emacs-lisp
(setq sentence-end-double-space nil)
#+END_SRC

** Recenter screen

Emacs lets you move the current line to the top, middle or bottom of the screen to get appropriate context. The default goes to the middle first. I prefer that the default goes to the top first. Let's change this.

#+BEGIN_SRC emacs-lisp
(setq recenter-positions '(top middle bottom))
#+END_SRC

** Better wild cards in search

The built-in incremental search is pretty good but the most common regex I type is =.*= which stands for anything. This makes sure space between words acts the same way. It's much better for me to use it now.

#+BEGIN_SRC emacs-lisp
(setq search-whitespace-regexp ".*?")
#+END_SRC

** Narrow to region

This is such a an amazing feature but is disabled by default. Let's re-enable it. For further reference on narrow region, [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Narrowing.html][refer to the Emacs manual]].

#+BEGIN_SRC emacs-lisp
(put 'narrow-to-region 'disabled nil)
#+END_SRC

** PDF files

Emacs has the built-in [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Document-View.html][DocView]] mode which lets me view PDFs. Since I use Org and note taking extensively, I actually prefer reading PDFs in Emacs. Not to mention, this is one of the few PDF readers that lets me view the PDF in split-views which is immensely useful while reading research papers.

#+BEGIN_SRC emacs-lisp
(setq doc-view-continuous t)
#+END_SRC

** Window management

[[https://www.emacswiki.org/emacs/WinnerMode][Winner mode]] is an Emacs built-in package that lets you undo and redo window configurations. Incredibly useful since I keep splitting and merging windows all the time. Let's enable it.

#+BEGIN_SRC emacs-lisp
(when (fboundp 'winner-mode)
  (winner-mode 1))
#+END_SRC

** Recent files

An Emacs "mode" is a collection of behavior. It has both major and minor modes. One such useful mode is the =recentf-mode=, which stands for recent files mode. Let's give configure some options and enable it.

#+BEGIN_SRC emacs-lisp
(savehist-mode)
;; Recentf mode changes
(setq recentf-max-saved-items 1000
      recentf-exclude '("/tmp/" "/ssh:" ".*/personal\\.*" ".*\\.emacs\\.*"))
(recentf-mode)
#+END_SRC

** Fullscreen

In Mac, the default fullscreen goes to a new workspace. Change this behavior so that it's non-native.

#+BEGIN_SRC emacs-lisp :tangle no
(setq ns-use-native-fullscreen nil)
#+END_SRC

** Fonts
#+BEGIN_SRC emacs-lisp
(use-package cnfonts
  :ensure t
  :config
  (cnfonts-enable))
#+END_SRC
** Mouse wheel scroll
#+BEGIN_SRC emacs-lisp
(setq mouse-wheel-scroll-amount '(1 ((shift) . 1)((control)))
mouse-wheel-progressive-speed nil
scroll-step 1)
#+END_SRC
* Helper functions
#+BEGIN_SRC emacs-lisp
(defun kill-default-buffer ()
  "Kill the currently active buffer -- set to C-x k so that users are not asked which buffer they want to kill."
  (interactive)
  (let (kill-buffer-query-functions) (kill-buffer)))

(defun kill-buffer-if-file (buf)
  "Kill a buffer only if it is file-based."
  (when (buffer-file-name buf)
    (when (buffer-modified-p buf)
        (when (y-or-n-p (format "Buffer %s is modified - save it?" (buffer-name buf)))
            (save-some-buffers nil buf)))
    (set-buffer-modified-p nil)
    (kill-buffer buf)))

(defun kill-all-buffers ()
    "Kill all file-based buffers."
    (interactive)
    (mapc (lambda (buf) (kill-buffer-if-file buf))
     (buffer-list)))

(defun kill-buffer-and-window ()
  "Close the current window and kill the buffer it's visiting."
  (interactive)
  (progn
    (kill-buffer)
    (delete-window)))

(defun create-new-buffer ()
  "Create a new buffer named *new*[num]."
  (interactive)
  (switch-to-buffer (generate-new-buffer-name "*new*")))

(defun insert-semicolon-at-end-of-line ()
  "Add a closing semicolon from anywhere in the line."
  (interactive)
  (save-excursion
    (end-of-line)
    (insert ";")))

(defun comment-current-line-dwim ()
  "Comment or uncomment the current line."
  (interactive)
  (save-excursion
    (push-mark (beginning-of-line) t t)
    (end-of-line)
    (comment-dwim nil)))

(defun newline-anywhere ()
  "Add a newline from anywhere in the line."
  (interactive)
  (end-of-line)
  (newline-and-indent))

(defun increase-window-height (&optional arg)
  "Make the window taller by one line. Useful when bound to a repeatable key combination."
  (interactive "p")
  (enlarge-window arg))

(defun decrease-window-height (&optional arg)
  "Make the window shorter by one line. Useful when bound to a repeatable key combination."
  (interactive "p")
  (enlarge-window (- 0 arg)))

(defun decrease-window-width (&optional arg)
  "Make the window narrower by one column. Useful when bound to a repeatable key combination."
  (interactive "p")
  (enlarge-window (- 0 arg) t))

(defun increase-window-width (&optional arg)
  "Make the window wider by one column. Useful when bound to a repeatable key combination."
  (interactive "p")
  (enlarge-window arg t))

(defun rename-current-buffer-file ()
  "Renames current buffer and file it is visiting."
  (interactive)
  (let ((name (buffer-name))
        (filename (buffer-file-name)))
    (if (not (and filename (file-exists-p filename)))
        (error "Buffer '%s' is not visiting a file!" name)
      (let ((new-name (read-file-name "New name: " filename)))
        (if (get-buffer new-name)
            (error "A buffer named '%s' already exists!" new-name)
          (rename-file filename new-name 1)
          (rename-buffer new-name)
          (set-visited-file-name new-name)
          (set-buffer-modified-p nil)
          (message "File '%s' successfully renamed to '%s'"
                   name (file-name-nondirectory new-name)))))))
(defun delete-current-buffer-file ()
  "Removes file connected to current buffer and kills buffer."
  (interactive)
  (let ((filename (buffer-file-name))
        (buffer (current-buffer))
        (name (buffer-name)))
    (if (not (and filename (file-exists-p filename)))
        (ido-kill-buffer)
      (when (yes-or-no-p "Are you sure you want to remove this file? ")
        (delete-file filename)
        (kill-buffer buffer)
        (message "File '%s' successfully removed" filename)))))

;; Create a new instance of emacs
(when window-system
  (defun new-emacs-instance ()
    (interactive)
    (let ((path-to-emacs
           (locate-file invocation-name
                        (list invocation-directory) exec-suffixes)))
      (call-process path-to-emacs nil 0 nil))))
#+END_SRC
* Modal states
** General

[[https://github.com/noctuid/general.el][general]] provides a more convenient way to bind keys in emacs for both evil and non-evil users.

#+BEGIN_SRC emacs-lisp
  (use-package general
    :ensure t
    :init
    (general-create-definer general-leader-key
                            :states '(normal insert emacs visual)
                            :non-normal-prefix "M-SPC"
                            :prefix "SPC"))
#+END_SRC
*** Default modal keybindings
#+BEGIN_SRC emacs-lisp
#+END_SRC

** Evil
#+BEGIN_SRC emacs-lisp
  (use-package evil
    :ensure t
    :demand t
    :init
    (setq evil-emacs-state-cursor 'bar)
    (setq evil-default-state 'emacs)
    (setq evil-disable-insert-state-bindings t)
    :config
    (evil-mode 1)
  :general 
    (general-define-key :states '(insert emacs)
                        "f" (general-key-dispatch 'self-insert-command
                              :timeout 0.25
                              "d" 'evil-normal-state))
 (general-leader-key 
    "hT" 'evil-totur-start
    "se" 'evil-iedit-state/iedit-mode
    ))
#+END_SRC
** Hydras

[[https://github.com/abo-abo/hydra][Hydra]] is not strictly a modal package but it is one that lets you define sticky bindings and I would call it semi-modal. I love it and need it. Currently, I don't define an hydras. They are defined under appropriate sections.

#+BEGIN_SRC emacs-lisp
(use-package hydra
  :ensure t)
#+END_SRC

* Key hints
** Which key

Emacs has 100s of bindings and it is impossible to remember them all. Sometimes I can remember the start of a key chord but not the entire one. [[https://github.com/justbur/emacs-which-key][Which-key]] is a package that gives you key hints on delay or if prompted. I really like it and use it extensively to setup the modal state.

#+BEGIN_SRC emacs-lisp
(use-package which-key
  :ensure t
  ;:defer t
  :diminish which-key-mode
  :init
  (setq which-key-sort-order 'which-key-key-order-alpha)
  :general 
    (general-leader-key "?" 
         '(which-key-show-top-level :which-key "top level bindings"))

  :config
  ;; Replacements for how KEY is replaced when which-key displays
  ;;   KEY ‚Üí FUNCTION
  ;; Eg: After "C-c", display "right ‚Üí winner-redo" as "‚ñ∂ ‚Üí winner-redo"
  (setq which-key-key-replacement-alist
        '(("<\\([[:alnum:]-]+\\)>" . "\\1")
          ("left"                  . "‚óÄ")
          ("right"                 . "‚ñ∂")
          ("up"                    . "‚ñ≤")
          ("down"                  . "‚ñº")
          ("delete"                . "DEL") ; delete key
          ("\\`DEL\\'"             . "BS") ; backspace key
          ("next"                  . "PgDn")
          ("prior"                 . "PgUp"))

        ;; List of "special" keys for which a KEY is displayed as just
        ;; K but with "inverted video" face... not sure I like this.
        which-key-special-keys '("RET" "DEL" ; delete key
                                 "ESC" "BS" ; backspace key
                                 "SPC" "TAB")

        ;; Replacements for how part or whole of FUNCTION is replaced:
        which-key-description-replacement-alist
        '(("Prefix Command" . "prefix")
          ("\\`calc-"       . "") ; Hide "calc-" prefixes when listing M-x calc keys
          ("\\`projectile-" . "ùìü/")
          ("\\`org-babel-"  . "ob/"))

        ;; Underlines commands to emphasize some functions:
        which-key-highlighted-command-list
        '("\\(rectangle-\\)\\|\\(-rectangle\\)"
          "\\`org-"))
  (which-key-mode))
#+END_SRC

** Discover my major

[[https://github.com/steckerhalter/discover-my-major][This package]] helps to discover the major mode bindings. I use it very occasionally and hence not binding it to any modal binding.

#+BEGIN_SRC emacs-lisp
(use-package discover-my-major
  :ensure t
  :general 
  (general-leader-key 
  "hm" 'discover-my-major
  "hM" 'discover-my-mode))
#+END_SRC

* File Manager
** dired

[[https://www.gnu.org/software/emacs/manual/html_node/emacs/Dired.html][Dired]] is an amazing file/directory browser that comes bundled with Emacs but I don't like it displaying all the details regarding the files when I open it. I prefer it minimal.

#+BEGIN_SRC emacs-lisp
(use-package dired
  :bind (:map dired-mode-map
              ("C-c C-e" . wdired-change-to-wdired-mode))
  :general 
    (general-leader-key
            :keymaps 'dired-mode-map
            "fo" 'ergoemacs-open-in-external-app
            "fO" 'ergoemacs-open-in-desktop)
  :init
  (setq dired-dwim-target t
        dired-recursive-copies 'always
        dired-recursive-deletes 'always
        dired-listing-switches "-alht")
  :config
  (defun ergoemacs-open-in-external-app ()
    "Open the current file or dired marked files in external app."
    (interactive)
    (let ( doIt
           (myFileList
            (cond
             ((string-equal major-mode "dired-mode") (dired-get-marked-files))
             (t (list (buffer-file-name))) ) ) )

      (setq doIt (if (<= (length myFileList) 5)
                     t
                   (y-or-n-p "Open more than 5 files?") ) )

      (when doIt
        (cond
         ((string-equal system-type "windows-nt")
          (mapc (lambda (fPath) (w32-shell-execute "open" (replace-regexp-in-string "/" "\\" fPath t t)) ) myFileList)
          )
         ((string-equal system-type "darwin")
          (mapc (lambda (fPath) (shell-command (format "open \"%s\"" fPath)) )  myFileList) )
         ((string-equal system-type "gnu/linux")
          (mapc (lambda (fPath) (let ((process-connection-type nil)) (start-process "" nil "xdg-open" fPath)) ) myFileList) ) ) ) ) )

  (defun ergoemacs-open-in-desktop ()
    "Show current file in desktop (OS's file manager)."
    (interactive)
    (cond
     ((string-equal system-type "windows-nt")
      (w32-shell-execute "explore" (replace-regexp-in-string "/" "\\" default-directory t t)))
     ((string-equal system-type "darwin") (shell-command "open ."))
     ((string-equal system-type "gnu/linux")
      (let ((process-connection-type nil)) (start-process "" nil "xdg-open" "."))
      ;; (shell-command "xdg-open .") ;; 2013-02-10 this sometimes froze emacs till the folder is closed. ‚Åñ with nautilus
      ) ))
  (add-hook 'dired-mode-hook
            #'(lambda ()
                (define-key dired-mode-map (kbd "RET") 'dired-find-alternate-file) ; was dired-advertised-find-file

                (define-key dired-mode-map (kbd "^") (lambda () (interactive) (find-alternate-file "..")))  ; was dired-up-directory
                (define-key dired-mode-map "\C-co" 'ergoemacs-open-in-external-app)
                (define-key dired-mode-map "\C-cO" 'ergoemacs-open-in-desktop)))
  (add-hook 'dired-mode-hook 'dired-hide-details-mode))
#+END_SRC

In dired, M-> and M- never take me where I want to go.

Instead of taking me to the very beginning or very end, they now take me to the first or last file.

#+BEGIN_SRC emacs-lisp
(defun dired-back-to-top ()
  (interactive)
  (beginning-of-buffer)
  (dired-next-line 4))

;(define-key dired-mode-map
;  (vector 'remap 'beginning-of-buffer) 'dired-back-to-top)

(defun dired-jump-to-bottom ()
  (interactive)
  (end-of-buffer)
  (dired-next-line -1))

;(define-key dired-mode-map
;  (vector 'remap 'end-of-buffer) 'dired-jump-to-bottom)
#+END_SRC
** peep-dired
[[https://github.com/asok/peep-dired][peep-dired]] is a minor mode that can be enabled from a dired buffer. Once enabled it will show the file from point in the other window. Moving to the other file within the dired buffer with down/up or C-n/C-p will display different file. Hitting SPC will scroll the peeped file down, whereas C-SPC and backspace will scroll it up.

#+BEGIN_SRC emacs-lisp
;;preview files in dired
(use-package peep-dired
  :ensure t
  :defer t ; don't access `dired-mode-map' until `peep-dired' is loaded
  :bind (:map dired-mode-map
              ("P" . peep-dired)))
#+END_SRC
** dired-narrow

 [[https://github.com/Fuco1/dired-hacks][dired-hacks]], then you can type filter strings to dynamically filter down a dired listing to match the filter.

#+BEGIN_SRC emacs-lisp
;;narrow dired to match filter
(use-package dired-narrow
  :ensure t
  :bind (:map dired-mode-map
              ("/" . dired-narrow)))
#+END_SRC
** quick preview
[[https://github.com/myuhe/quick-preview.el][Quick-preview]] is an application for previewing file using external tool.

 You can choose external tool below, 

 - [[https://en.wikipedia.org/wiki/Sushi_(software)][GNOME Sushi]]
 - [[http://gloobus.net/gloobus-preview/][Gloobus preview]]
 - [[https://en.wikipedia.org/wiki/Quick_Look][Quick Look]]

 For Mac user, The default value is set to  =Quick Look=, For Linux user, set to =GNOME Sushi=.

#+BEGIN_SRC emacs-lisp
(use-package quick-preview
  :ensure t
  :general
  (general-define-key :keymaps 'dired-mode-map
                      :states '(insert emacs)
                      "SPC" 'quick-preview-at-point))
#+END_SRC
* Navigation
** helm

[[http://tuhdo.github.io/helm-intro.html][Helm]] is an extremely powerful package that provides a search interface that narrows the matches as you type. 
What makes it powerful is the range of back-ends that you can access through helm. I don‚Äôt use it for a lot
of things (I slightly prefer ivy in general), but one of my favourites is helm-for-files. This gives you a 
search interface where you start typing the name of a file and it narrows a list of files from multiple useful
 sources: currently opened files; recent files; bookmarked files; files in the current directory; and files anywhere
 on your system using your system‚Äôs locate command. Basically, it find any file anywhere on your system, showing
 you the most likely matches first. Hitting RET to select a file opens it in Emacs as usual.

#+BEGIN_SRC emacs-lisp
(use-package helm
  :ensure t
  :init
  (progn
    (require 'helm-config)
    ;; limit max number of matches displayed for speed
    (setq helm-candidate-number-limit 100)
    ;; ignore boring files like .o and .a
    (setq helm-ff-skip-boring-files t)
    ;; replace locate with spotlight on Mac
    (setq helm-locate-command "mdfind -name %s %s"))
  :bind (("C-x f" . helm-for-files)))
#+END_SRC
** Flx

[[https://github.com/lewang/flx][Flx]] is a package that helps in fuzzy file narrowing like [[http://www.sublimetext.com][Sublime Text]]. The most prominent package that uses this is =flx-ido= found in the same repository. I find =ivy='s built-in fuzzy matching more than good enough. However, this is in case I need something different/more and when this is installed, Ivy automatically uses this for fuzzy finding. This is particularly useful if I decide to use [[*Helm][Helm]] full time instead of ivy.

#+BEGIN_SRC emacs-lisp
(use-package flx-ido
  :ensure t
  :config 
  (flx-ido-mode 1)
  (setq ido-enable-flex-matching t)
  (setq ido-use-faces nil))
#+END_SRC
** ido
#+BEGIN_SRC emacs-lisp
(use-package ido
  :ensure t
  :config
  (ido-mode 1)
  (ido-everywhere 1)
  (defun ido-sort-mtime ()
    "Reorder the IDO file list to sort from most recently modified."
    (setq ido-temp-list
          (sort ido-temp-list
                (lambda (a b)
                  (ignore-errors
                    (time-less-p
                     (sixth (file-attributes (concat ido-current-directory b)))
                     (sixth (file-attributes (concat ido-current-directory a))))))))
    (ido-to-end  ;; move . files to end (again)
     (delq nil (mapcar
              (lambda (x) (and (char-equal (string-to-char x) ?.) x))
              ido-temp-list))))
  
  (add-hook 'ido-make-file-list-hook 'ido-sort-mtime)
  (add-hook 'ido-make-dir-list-hook 'ido-sort-mtime))
#+END_SRC
** ido-grid-mode
#+BEGIN_SRC emacs-lisp
(use-package ido-grid-mode
  :ensure t
  :config
  (ido-grid-mode 1))
#+END_SRC
** Smex

[[https://github.com/nonsequitur/smex][smex]] is an amazing program that helps order the =M-x= commands based on usage and recent items. Let's install it.

#+BEGIN_SRC emacs-lisp
(use-package smex
  :ensure t
  :init (smex-initialize)
  :config
  (global-set-key (kbd "M-x") 'smex)
  (global-set-key (kbd "C-x x") 'smex)
  (global-set-key (kbd "M-X") 'smex-major-mode-commands)
  )
#+END_SRC
** Beacon mode

[[https://github.com/Malabarba/beacon][Beacon]] is just a tiny utility that indicates the cursor position when the cursor moves suddenly. You can also manually invoke it by calling the function =beacon-blink= and it is bound by default.

#+BEGIN_SRC emacs-lisp
  (use-package beacon
    :ensure t
    :demand t
    :diminish beacon-mode
    :general 
    (general-leader-key "sc" 
         '(beacon-blink :which-key "Blink cursor"))
    :config
    (beacon-mode 1))
#+END_SRC

** Undo tree

The default Emacs [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Undo.html][undo]] command is weird. Better undo and redo states are given by [[https://www.emacswiki.org/emacs/UndoTree][undo-tree]] mode and, as an added bonus, also gives a visualization tree

#+BEGIN_SRC emacs-lisp
(use-package undo-tree
  :ensure t
  :diminish undo-tree-mode
  :general 
  (general-define-key :states '(normal)
                      "br" '(undo-tree-redo)
                      "bu" '(undo-tree-undo)
                      "bU" '(undo-tree-visualize)
                      "U" '(undo-tree-visualize :which-key "undo tree"))
  :config
  (global-undo-tree-mode 1)
  (global-set-key (kbd "M-z") 'undo)
  (defalias 'redo 'undo-tree-redo)
  (global-set-key (kbd "M-Z") 'redo))
#+END_SRC
** Goto the last change

[[https://www.emacswiki.org/emacs/GotoChg][This package]] goes to the last place I made a change in the file, and compliments marks.

#+BEGIN_SRC emacs-lisp
(use-package goto-chg
  :ensure t
  :general 
    (general-leader-key
            "x;" '(goto-last-change :which-key "goto last change")
            "x," '(goto-last-change-reverse :which-key "goto last change reverse")))
#+END_SRC
** scroll-restore

[[https://github.com/emacsmirror/scroll-restore][scroll-restore]]

#+BEGIN_SRC emacs-lisp
(use-package scroll-restore
  :ensure t
  :config 
(scroll-restore-mode 1)
;; Allow scroll-restore to modify the cursor face
(setq scroll-restore-handle-cursor t)
;; Make the cursor invisible while POINT is off-screen
(setq scroll-restore-cursor-type nil)
;; Jump back to the original cursor position after scrolling
(setq scroll-restore-jump-back t)
  :general 
    (general-leader-key
            "tS" 'scroll-restore-mode))
#+END_SRC
** Avy

[[https://github.com/abo-abo/avy][Avy]] is a package that lets you jump anywhere on screen based on character, characters, lines or words. It's one of my most used packages.

#+BEGIN_SRC emacs-lisp
(use-package avy
  :ensure t
  :init
  (setq avy-keys-alist
        `((avy-goto-char-timer . (?j ?k ?l ?f ?s ?d ?e ?r ?u ?i))
          (avy-goto-line . (?j ?k ?l ?f ?s ?d ?e ?r ?u ?i))))
  (setq avy-style 'pre)
  :general 
    (general-leader-key
            "jb" 'avy-pop-mark
            "jj" 'avy-goto-char-timer
            "jl" 'avy-goto-line))
#+END_SRC
** jump-tree
[[https://github.com/yangwen0228/jump-tree][jump-tree]] is an undo-tree like jumping implementation, so that we can jump back and forth in a tree way like undo-tree.

Just call M-x global-jump-tree-mode and then use M-, to jump previous, M-. to jump next and C-x j to view the jump tree visualizer.

#+BEGIN_SRC emacs-lisp
(use-package jump-tree
  :ensure t
  :diminish jump-tree-mode
  :init
  (global-jump-tree-mode))
  ;:general 
  ;  (general-leader-key
  ;          "<left>" 'point-undo
  ;          "<right>" 'point-redo))
#+END_SRC
** Highlight symbol

[[https://github.com/nschum/highlight-symbol.el][This package]] is pretty simple. It adds functionality to highlight the current word or symbol and navigate to other instances.

#+BEGIN_SRC emacs-lisp
(use-package highlight-symbol
  :ensure t
  :general 
    (general-leader-key
            "xn" 'highlight-symbol-next
            "xp" 'highlight-symbol-prev)
  :config
  (highlight-symbol-nav-mode))
#+END_SRC
** Toggle zoom

I generally have multiple windows open and might need to zoom into one every now and then. I also might split them and change them. I would like to think of [[https://github.com/syohex/emacs-zoom-window][this package]] as smart zoom where I zoom into a window, split further, and have =winner= handle the history and just zoom right back out and continue working on the previous configuration. It also indicates if you are zoomed in or not via the status line color.

#+BEGIN_SRC emacs-lisp
(use-package zoom-window
  :ensure t
  :general 
    (general-leader-key
            "wm" '(zoom-window-zoom :which-key "zoom window")))
#+END_SRC
** Code documentation

[[https://kapeli.com/dash][Dash]] is a nice little app that stores documents offline for reference. Let's [[https://github.com/stanaka/dash-at-point][bring that to Emacs]].

#+BEGIN_SRC emacs-lisp :tangle no
(use-package dash-at-point
  :ensure t
  :bind (("C-c I" . dash-at-point))
  :bind* (("M-m SPC y" . dash-at-point-with-docset)
          ("M-m SPC Y" . dash-at-point)))
#+END_SRC
Which key modal explanation

#+BEGIN_SRC emacs-lisp :tangle no
(which-key-add-key-based-replacements
  "I"     "info at point"
  "SPC y" "documentation prompt"
  "SPC Y" "documentation at point")
#+END_SRC
** Custom functions
*** Open the =config.org= file

This function opens the current file when invoked from anywhere so that I can edit my configuration quickly, whenever I want

#+BEGIN_SRC emacs-lisp
(defun sk/open-config ()
  "Opens the configuration file from anywhere"
  (interactive)
  (find-file (concat user-emacs-directory "config.org")))
(defun sk/open-init ()
  "Opens the configuration file from anywhere"
  (interactive)
  (find-file (concat user-emacs-directory "init.el")))
#+END_SRC

**** Key binding

 #+BEGIN_SRC emacs-lisp
 (general-leader-key 
  "fec" '(sk/open-config :which-key "view config file")
  "fei" '(sk/open-init :which-key "view init file"))
 #+END_SRC
*** Non native full screen

As mentioned [[*Fullscreen][here]], this is to further ensure that we use a non-native fullscreen.

#+BEGIN_SRC emacs-lisp
(defun sk/toggle-frame-fullscreen-non-native ()
  "Toggle full screen non-natively. Uses the `fullboth' frame paramerter
   rather than `fullscreen'. Useful to fullscreen on OSX w/o animations."
  (interactive)
  (modify-frame-parameters
   nil
   `((maximized
      . ,(unless (memq (frame-parameter nil 'fullscreen) '(fullscreen fullboth))
           (frame-parameter nil 'fullscreen)))
     (fullscreen
      . ,(if (memq (frame-parameter nil 'fullscreen) '(fullscreen fullboth))
             (if (eq (frame-parameter nil 'maximized) 'maximized)
                 'maximized)
           'fullboth)))))
#+END_SRC

**** Key binding

#+BEGIN_SRC emacs-lisp
(general-leader-key "tF" '(sk/toggle-frame-fullscreen-non-native :which-key "toggle fullscreen"))
#+END_SRC
*** Split window and move

I hate the default Emacs behavior of split windows which just splits the window but doesn't go there.

#+BEGIN_SRC emacs-lisp
(defun sk/split-below-and-move ()
  (interactive)
  (split-window-below)
  (other-window 1))
(defun sk/split-right-and-move ()
  (interactive)
  (split-window-right)
  (other-window 1))
#+END_SRC

**** Key binding

This is one of the few occasions I just replace it with my custom function because I use it so much. Since the defaults of [[*Global%20prefixed%20keys][modalka]] and [[*Global%20prefixed%20keys][which-key]] already use and define this binding, there is no need for another one.

#+BEGIN_SRC emacs-lisp
(bind-keys
  ("C-x 2" . sk/split-below-and-move)
  ("C-x 3" . sk/split-right-and-move))
#+END_SRC

*** Turn the adjoining window (only with 2 windows)

#+BEGIN_SRC emacs-lisp
(defun sk/other-window-down ()
  "Scrolls down in adjoining window"
  (interactive)
  (other-window 1)
  (scroll-up-command)
  (other-window 1))
(defun sk/other-window-up ()
  "Scrolls up in adjoining window"
  (interactive)
  (other-window 1)
  (scroll-down-command)
  (other-window 1))
#+END_SRC

**** Key binding

#+BEGIN_SRC emacs-lisp
 (general-leader-key 
  "w]" '(sk/other-window-down :which-key "adjacent pdf next page")
  "w[" '(sk/other-window-up :which-key "adjacent pdf prev page"))
#+END_SRC

*** Smarter start of line

This function, from [[http://emacsredux.com/blog/2013/05/22/smarter-navigation-to-the-beginning-of-a-line/][emacsredux blog]], defines a better start of line and remaps =C-a= for it.

#+BEGIN_SRC emacs-lisp
(defun sk/smarter-move-beginning-of-line (arg)
  "Move point back to indentation of beginning of line.
Move point to the first non-whitespace character on this line.
If point is already there, move to the beginning of the line.
Effectively toggle between the first non-whitespace character and
the beginning of the line.
If ARG is not nil or 1, move forward ARG - 1 lines first.  If
point reaches the beginning or end of the buffer, stop there."
  (interactive "^p")
  (setq arg (or arg 1))
  ;; Move lines first
  (when (/= arg 1)
    (let ((line-move-visual nil))
      (forward-line (1- arg))))
  (let ((orig-point (point)))
    (back-to-indentation)
    (when (= orig-point (point))
      (move-beginning-of-line 1))))
#+END_SRC

**** Key binding

#+BEGIN_SRC emacs-lisp
;; remap C-a to `smarter-move-beginning-of-line'
(global-set-key [remap move-beginning-of-line]
                'sk/smarter-move-beginning-of-line)
#+END_SRC

*** Rotate the windows

[[https://github.com/magnars/.emacs.d/blob/master/defuns/buffer-defuns.el][Stolen]] from Magnar Sveen's configuration. This function is bound to the [[*Window%20navigation][hydra]] defined for window navigation.

#+BEGIN_SRC emacs-lisp
(defun sk/rotate-windows ()
  "Rotate your windows"
  (interactive)
  (cond ((not (> (count-windows)1))
         (message "You can't rotate a single window!"))
        (t
         (setq i 1)
         (setq numWindows (count-windows))
         (while  (< i numWindows)
           (let* (
                  (w1 (elt (window-list) i))
                  (w2 (elt (window-list) (+ (% i numWindows) 1)))

                  (b1 (window-buffer w1))
                  (b2 (window-buffer w2))

                  (s1 (window-start w1))
                  (s2 (window-start w2))
                  )
             (set-window-buffer w1  b2)
             (set-window-buffer w2 b1)
             (set-window-start w1 s2)
             (set-window-start w2 s1)
             (setq i (1+ i)))))))
#+END_SRC
**** Key binding

#+BEGIN_SRC emacs-lisp
 (general-leader-key 
    "wr" 'sk/rotate-windows
    )
#+END_SRC

*** Open the current HTML file in browser

Not sure where I got this from. Most likely Magnar Sveen.

#+BEGIN_SRC emacs-lisp
(defun sk/browse-current-file ()
  "Open the current file as a URL using `browse-url'."
  (interactive)
  (let ((file-name (buffer-file-name)))
    (if (and (fboundp 'tramp-tramp-file-p)
             (tramp-tramp-file-p file-name))
        (error "Cannot open tramp file")
      (browse-url (concat "file://" file-name)))))
#+END_SRC

**** Key binding

#+BEGIN_SRC emacs-lisp
 (general-leader-key 
    "wB" '(sk/browse-current-file :which-key "browse file in browser")
    )
#+END_SRC
*** Switching Next/Previous User Buffers
#+BEGIN_SRC emacs-lisp
(defun next-user-buffer ()
  "Switch to the next user buffer.
User buffers are those whose name does not start with *."
  (interactive)
  (next-buffer)
  (let ((i 0))
    (while (and (string-match "^*" (buffer-name)) (< i 50))
      (setq i (1+ i)) (next-buffer) )))

(defun previous-user-buffer ()
  "Switch to the previous user buffer.
User buffers are those whose name does not start with *."
  (interactive)
  (previous-buffer)
  (let ((i 0))
    (while (and (string-match "^*" (buffer-name)) (< i 50))
      (setq i (1+ i)) (previous-buffer) )))

(defun next-emacs-buffer ()
  "Switch to the next emacs buffer.
Emacs buffers are those whose name starts with *."
  (interactive)
  (next-buffer)
  (let ((i 0))
    (while (and (not (string-match "^*" (buffer-name))) (< i 50))
      (setq i (1+ i)) (next-buffer) )))

(defun previous-emacs-buffer ()
  "Switch to the previous emacs buffer.
Emacs buffers are those whose name starts with *."
  (interactive)
  (previous-buffer)
  (let ((i 0))
    (while (and (not (string-match "^*" (buffer-name))) (< i 50))
      (setq i (1+ i)) (previous-buffer) )))

  (general-leader-key 
   "bn" '(next-user-buffer :which-key "next buffer")
   "bp" '(previous-user-buffer :which-key "previous buffer")
   "bN" 'next-emacs-buffer
   "bP" 'previous-emacs-buffer
   )
#+END_SRC
*** triple wheel
#+BEGIN_SRC emacs-lisp
(defvar *my-previous-buffer* t
  "can we switch?")

(defun my-previous-buffer ()
  (interactive)
  (message "custom prev: *my-previous-buffer*=%s" *my-previous-buffer*)
  (when *my-previous-buffer*
    (previous-user-buffer)
    (setq *my-previous-buffer* nil)
    (run-at-time "1 sec" nil (lambda ()
                               (setq *my-previous-buffer* t)))))

(defvar *my-next-buffer* t
  "can we switch?")

(defun my-next-buffer ()
  (interactive)
  (message "custom prev: *my-next-buffer*=%s" *my-next-buffer*)
  (when *my-next-buffer*
    (next-user-buffer)
    (setq *my-next-buffer* nil)
    (run-at-time "1 sec" nil (lambda ()
                               (setq *my-next-buffer* t)))))

(global-set-key [triple-wheel-right] 'my-previous-buffer)
(global-set-key [triple-wheel-left] 'my-next-buffer)
#+END_SRC
* Visual

This section adds some packages which enhance visual feedback and mostly work behind the scenes to get stuff done.

** Volatile highlights

I particularly like this [[https://github.com/k-talo/volatile-highlights.el][package]]. It gives visual feedback on some of the common operations like undo, copying and pasting and also inherits the color scheme very well.

#+BEGIN_SRC emacs-lisp
(use-package volatile-highlights
  :ensure t
  :diminish volatile-highlights-mode
  :config
  (add-hook 'after-init-hook 'global-color-identifiers-mode))
#+END_SRC

** Color Identifiers Mode

[[https://github.com/ankurdave/color-identifiers-mode][Color Identifiers]] is a minor mode for Emacs that highlights each source code identifier uniquely based on its name.

#+BEGIN_SRC emacs-lisp
(use-package color-identifiers-mode
  :ensure t
  :diminish color-identifiers-mode
  :config
  (volatile-highlights-mode t))
#+END_SRC
** Mode line

[[https://github.com/TheBB/spaceline][Spaceline]] is similar to the [[http://spacemacs.org][Spacemacs]] mode-line. It's pretty cool.

#+BEGIN_SRC emacs-lisp
(use-package spaceline
  :ensure t
  :demand t
  :init
  (setq powerline-default-separator 'alternate)
  :config
  (require 'spaceline-config)
  (spaceline-spacemacs-theme)
  (spaceline-helm-mode))
#+END_SRC
** tabbar
#+BEGIN_SRC emacs-lisp
(use-package tabbar
  :ensure t
  :bind
  ("<C-S-iso-lefttab>" . tabbar-backward)
  ("<C-tab>" . tabbar-forward)

  :config
  (set-face-attribute
   'tabbar-button nil
   :box '(:line-width 1 :color "gray19"))

  (set-face-attribute
   'tabbar-selected nil
   :foreground "orange"
   :background "gray19"
   :box '(:line-width 1 :color "gray19"))

  (set-face-attribute
   'tabbar-unselected nil
   :foreground "gray75"
   :background "gray25"
   :box '(:line-width 1 :color "gray19"))

  (set-face-attribute
   'tabbar-highlight nil
   :foreground "black"
   :background "orange"
   :underline nil
   :box '(:line-width 1 :color "gray19" :style nil))

  (set-face-attribute
   'tabbar-modified nil
   :foreground "orange red"
   :background "gray25"
   :box '(:line-width 1 :color "gray19"))

  (set-face-attribute
   'tabbar-selected-modified nil
   :foreground "orange red"
   :background "gray19"
   :box '(:line-width 1 :color "gray19"))

  (custom-set-variables
   '(tabbar-separator (quote (0.2))))

  ;; Change padding of the tabs
  ;; we also need to set separator to avoid overlapping tabs by highlighted tabs
  ;; (custom-set-variables
  ;;  '(tabbar-separator (quote (1.0))))
  (defun tabbar-buffer-tab-label (tab)
    "Return a label for TAB.
  That is, a string used to represent it on the tab bar."
    (let ((label  (if tabbar--buffer-show-groups
                      (format " [%s] " (tabbar-tab-tabset tab))
                    (format " %s " (tabbar-tab-value tab)))))
      ;; Unless the tab bar auto scrolls to keep the selected tab
      ;; visible, shorten the tab label to keep as many tabs as possible
      ;; in the visible area of the tab bar.
      (if tabbar-auto-scroll-flag
          label
        (tabbar-shorten
         label (max 1 (/ (window-width)
                         (length (tabbar-view
                                  (tabbar-current-tabset)))))))))

  (defun px-tabbar-buffer-select-tab (event tab)
    "On mouse EVENT, select TAB."
    (let ((mouse-button (event-basic-type event))
          (buffer (tabbar-tab-value tab)))
      (cond
       ((eq mouse-button 'mouse-2) (with-current-buffer buffer (kill-buffer)))
       ((eq mouse-button 'mouse-3) (pop-to-buffer buffer t))
       (t (switch-to-buffer buffer)))
      (tabbar-buffer-show-groups nil)))

  (defun px-tabbar-buffer-help-on-tab (tab)
    "Return the help string shown when mouse is onto TAB."
    (if tabbar--buffer-show-groups
        (let* ((tabset (tabbar-tab-tabset tab))
               (tab (tabbar-selected-tab tabset)))
          (format "mouse-1: switch to buffer %S in group [%s]"
                  (buffer-name (tabbar-tab-value tab)) tabset))
      (format "\
mouse-1: switch to %S\n\
mouse-2: kill %S\n\
mouse-3: Open %S in another window"
              (buffer-name (tabbar-tab-value tab))
              (buffer-name (tabbar-tab-value tab))
              (buffer-name (tabbar-tab-value tab)))))

  (defun px-tabbar-buffer-groups ()
    "Sort tab groups."
    (list (cond ((or
                  (eq major-mode 'dired-mode)
                  (string-equal "*" (substring (buffer-name) 0 1))) "emacs")
                (t "user"))))
  (setq tabbar-help-on-tab-function 'px-tabbar-buffer-help-on-tab
        tabbar-select-tab-function 'px-tabbar-buffer-select-tab
        tabbar-buffer-groups-function 'px-tabbar-buffer-groups)

  :init
  (tabbar-mode 0))
#+END_SRC
** Code Block Folding
#+BEGIN_SRC emacs-lisp
(defun es/hs-show-all ()
  (interactive)
  (hs-minor-mode 1)
  (hs-show-all))

(defun es/hs-hide-all ()
  (interactive)
  (hs-minor-mode 1)
  (hs-hide-all))

(defun es/hs-toggle-hiding ()
  (interactive)
  (hs-minor-mode 1)
  (hs-toggle-hiding))


(use-package hs-minor-mode
  :general 
    (general-leader-key
            "xh" 'es/hs-toggle-hiding))
#+END_SRC
** Vimish fold - Fold regions based on selection

Syntax based folding is great and all but sometimes I need to fold some random piece of text and [[https://github.com/mrkkrp/vimish-fold][Vimish fold]] is good for that.

#+BEGIN_SRC emacs-lisp
(use-package vimish-fold
  :ensure t
  :commands (vimish-fold-toggle
             vimish-fold))
#+END_SRC
* Editing
** Default

Don't use tabs for indent; replace tabs with two spaces.
#+BEGIN_SRC emacs-lisp
(setq-default tab-width 2)
(setq-default indent-tabs-mode nil)
(setq-default js-indent-level 2)
#+END_SRC

newline-and-indent
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "RET") 'newline-and-indent)
#+END_SRC
Delete marked text on typing

#+BEGIN_SRC emacs-lisp
(delete-selection-mode t)
#+END_SRC

Show matching parens

#+BEGIN_SRC emacs-lisp
(show-paren-mode 1)
#+END_SRC

max kill-ring

#+BEGIN_SRC emacs-lisp
(setq kill-ring-max 200)
#+END_SRC
** make-buffer-file-executable
#+BEGIN_SRC emacs-lisp
(add-hook 'after-save-hook 'executable-make-buffer-file-executable-if-script-p)
#+END_SRC
** Commenting

[[https://github.com/remyferre/comment-dwim-2][comment-dwim-2]] improves on the existing =comment-dwim= command for easy commenting. Pretty useful.

#+BEGIN_SRC emacs-lisp
(use-package comment-dwim-2
  :ensure t
  :general 
    (general-leader-key
            "ct" '(comment-dwim-2 :which-key "comment line/region")))
#+END_SRC

** Visual replace

This is the [[https://github.com/benma/visual-regexp.el][good old search and replace]] as opposed to the fancy alternatives such as [[*Interactive edit][iedit]]. You search for a word in the buffer/region, type in the replacement and confirm each one by pressing =y= or =n= or just press =!= to apply this to everything.

#+BEGIN_SRC emacs-lisp
(use-package visual-regexp
  :ensure t
  :init
  (use-package visual-regexp-steroids :ensure t)
  :general 
  (general-leader-key
    "xr" '(vr/replace :which-key "replace word")
    "xq" '(vr/query-replace :which-key "query replace word/expression")))
#+END_SRC
** multiple edit
[[https://github.com/hlissner/evil-multiedit][evil-multiedit]]
#+BEGIN_SRC emacs-lisp
(use-package evil-multiedit
  :ensure t
  :config 
    (evil-multiedit-default-keybinds))
#+END_SRC
** Drag Stuff
[[https://github.com/rejeep/drag-stuff.el][Drag Stuff]] is a minor mode for Emacs that makes it possible to drag stuff (words, region, lines) around in Emacs.
#+BEGIN_SRC emacs-lisp
(use-package drag-stuff
  :ensure t
  :diminish drag-stuff-mode
  :config 
    (drag-stuff-global-mode 1)
    (drag-stuff-define-keys))
#+END_SRC
- Suggested key-bindings
To activate the suggested key-bindings, <M-up>, <M-down>, <M-right>, <M-left>
** counsel-yank-pop
[[https://github.com/abo-abo/swiper][counsel-yank-pop]] is a minor mode for Emacs that makes it possible to drag stuff (words, region, lines) around in Emacs.
#+BEGIN_SRC emacs-lisp
(use-package counsel
  :ensure t
  :bind
  (("M-y" . counsel-yank-pop)
   :map ivy-minibuffer-map
   ("M-y" . ivy-next-line)))
#+END_SRC
** Custom functions
*** Rename the current buffer and the file associated with it

[[https://github.com/magnars/.emacs.d/blob/master/defuns/file-defuns.el][Stolen]] from Magnar Sveen's config.

#+BEGIN_SRC emacs-lisp
(defun my/rename-current-buffer-file ()
  "Renames current buffer and file it is visiting."
  (interactive)
  (let ((name (buffer-name))
        (filename (buffer-file-name)))
    (if (not (and filename (file-exists-p filename)))
        (error "Buffer '%s' is not visiting a file!" name)
      (let ((new-name (read-file-name "New name: " filename)))
        (if (get-buffer new-name)
            (error "A buffer named '%s' already exists!" new-name)
          (rename-file filename new-name 1)
          (rename-buffer new-name)
          (set-visited-file-name new-name)
          (set-buffer-modified-p nil)
          (message "File '%s' successfully renamed to '%s'"
                   name (file-name-nondirectory new-name)))))))
#+END_SRC

**** Key binding

#+BEGIN_SRC emacs-lisp
(general-leader-key
            "fR" '(sk/rename-current-buffer-file :which-key "rename buffer and file"))
#+END_SRC

*** Delete the current buffer and the file associated with it

[[https://github.com/magnars/.emacs.d/blob/master/defuns/file-defuns.el][Stolen]] from Magnar Sveen's config.

#+BEGIN_SRC emacs-lisp
(defun my/delete-current-buffer-file ()
  "Removes file connected to current buffer and kills buffer."
  (interactive)
  (let ((filename (buffer-file-name))
        (buffer (current-buffer))
        (name (buffer-name)))
    (if (not (and filename (file-exists-p filename)))
        (ido-kill-buffer)
      (when (yes-or-no-p "Are you sure you want to remove this file? ")
        (delete-file filename)
        (kill-buffer buffer)
        (message "File '%s' successfully removed" filename)))))
#+END_SRC

**** Key binding

#+BEGIN_SRC emacs-lisp
(general-leader-key
            "fD" '(my/delete-current-buffer-file :which-key "delete buffer and file"))
#+END_SRC
* Project management
** Projectile

[[https://github.com/bbatsov/projectile][Projectile]] is a nice package for project navigation. It hijacks the =C-c p= prefix by default and you can learn more about its commands by pressing =C-c p= and waiting for which key to show hints.

#+BEGIN_SRC emacs-lisp
(use-package projectile
  :ensure t
  :general 
  (general-leader-key 
   "p!" 'projectile-run-shell-command-in-root
   "p%" 'projectile-replace-regexp
   "p&" 'projectile-run-async-shell-command-in-root
   "pa" 'projectile-toggle-between-implementation-and-test
   "pb" 'projectile-switch-to-buffer
   "pc" 'projectile-compile-project
   "pD" 'projectile-dired
   "pd" 'projectile-find-dir
   "pF" 'projectile-find-file-dwim
   "pf" 'projectile-find-file
   "/" 'projectile-find-file
   "pg" 'projectile-find-tag
   "pI" 'projectile-invalidate-cache
   "pk" 'projectile-kill-buffers
   "pp" 'projectile-switch-project
   "pR" 'projectile-replace
   "pr" 'projectile-recentf
   "pn" 'neotree-project-dir
   "pT" 'projectile-test-project
   "pv" 'projectile-vc)
  :init
  ;;NeoTree can be opened (toggled) at projectile project root
  (defun neotree-project-dir ()
    "Open NeoTree using the git root."
    (interactive)
    (let ((project-dir (projectile-project-root))
          (file-name (buffer-file-name)))
      (neotree-toggle)
      (if project-dir
          (if (neo-global--window-exists-p)
              (progn
                (neotree-dir project-dir)
                (neotree-find file-name)))
        (message "Could not find git project root."))))
  (setq projectile-file-exists-remote-cache-expire (* 10 60))
  (setq projectile-switch-project-action 'neotree-projectile-action)
  :diminish projectile-mode
  :config
  (projectile-global-mode))
#+END_SRC

**** Modal binding
Which key modal explanation

#+BEGIN_SRC emacs-lisp
(which-key-add-key-based-replacements
  "SPC d"   "project files"
  "SPC D"   "project switch"
  "SPC TAB" "alternate file")
#+END_SRC

** Ztree

[[https://github.com/fourier/ztree][ztree]] and its function =ztree-diff= is super useful when comparing directory trees.

#+BEGIN_SRC emacs-lisp
(use-package ztree
  :ensure t
  :general 
  (general-leader-key 
  "ft" '(ztree-dir :which-key "tree directory")
  "fT" '(ztree-diff :which-key "diff directories"))
  :init
  (setq ztree-dir-move-focus t))
#+END_SRC
** emacs-neotree

[[https://github.com/jaypei/emacs-neotree][emacs-neotree]] A Emacs tree plugin like NerdTree for Vim.

#+BEGIN_SRC emacs-lisp
(use-package neotree
  :ensure t
  :init (setq-default neo-show-hidden-files t)
  :general 
    (general-leader-key
            "fn" 'neotree-toggle))
#+END_SRC
** Perspective

[[https://github.com/nex3/perspective-el][Perspective]] creates different view ports in Emacs preserving the Window configuration. Super useful.

#+BEGIN_SRC emacs-lisp
(use-package perspective
  :ensure t
  :general 
    (general-leader-key
            "ls" 'persp-switch
            "lk" 'persp-kill
            "lp" 'persp-prev
            "ln" 'persp-next
            "ll" 'persp-switch-last
            "lR" 'persp-rename)
  :config
  (persp-mode 1)
  (setq projectile-switch-project-action 'neotree-projectile-action))
#+END_SRC
* Programming
** Editorconfig

[[http://editorconfig.org][Editorconfig]] is a small utility that is helpful in keeping the code clean as it takes care of the necessary indentation and can be used across editors.

#+BEGIN_SRC emacs-lisp
(use-package editorconfig
  :ensure t
  :demand t
  :diminish editorconfig-mode
  :config
  (editorconfig-mode 1))
#+END_SRC
** Web
*** Web mode

[[http://web-mode.org][This]] is a fully featured, supposedly awesome, package to edit HTML in Emacs.

#+BEGIN_SRC emacs-lisp
(use-package web-mode
  :ensure t
  :mode ("\\.html$" . web-mode))
#+END_SRC
*** JavaScript syntax highlighting

[[https://github.com/thomblake/js3-mode][This]] improves on the built-in JavaScript syntax highlighting.

#+BEGIN_SRC emacs-lisp
(use-package js2-mode
  :ensure t
  :mode ("\\.js$" . js2-mode))
#+END_SRC
*** SCSS syntax highlighting

Occasionally I'm forced to open SCSS files.

#+BEGIN_SRC emacs-lisp
(use-package scss-mode
  :ensure t
  :mode "\\.scss$")
#+END_SRC
*** JSON mode

Syntax highlighting for =json= files.

#+BEGIN_SRC emacs-lisp
(use-package json-mode
  :ensure t
  :mode "\\.json$")
#+END_SRC
*** Write fast HTML

[[https://github.com/smihica/emmet-mode][Emmet]] is very useful while writing HTML. Look in to the guide for more details as to how to use it.

#+BEGIN_SRC emacs-lisp
(use-package emmet-mode
  :ensure t
  :diminish (emmet-mode . "Œµ")
  :bind* (("C-)" . emmet-next-edit-point)
          ("C-(" . emmet-prev-edit-point))
  :commands (emmet-mode
             emmet-next-edit-point
             emmet-prev-edit-point))
#+END_SRC
*** JavaScript navigation

[[http://ternjs.net][Tern]] describes itself as a code analysis engine and [[https://github.com/ternjs/tern][this]] is an implementation to bring it into Emacs.

#+BEGIN_SRC emacs-lisp
(use-package tern
  :ensure t
  :diminish tern-mode
  :defer t
  :config
  (progn
    (setq tern-command (append tern-command '("--no-port-file")))
    (add-hook 'js2-mode-hook '(lambda () (tern-mode t)))))
#+END_SRC
*** Beautify

I'm not sure how useful [[https://github.com/yasuyk/web-beautify][this]] is but just like I have formatters for others, I'm keeping this.

#+BEGIN_SRC emacs-lisp
(use-package web-beautify
  :ensure t
  :commands (web-beautify-css
             web-beautify-css-buffer
             web-beautify-html
             web-beautify-html-buffer
             web-beautify-js
             web-beautify-js-buffer))
#+END_SRC
*** vueify-mmm-mode
#+BEGIN_SRC emacs-lisp
(use-package mmm-mode
  :ensure t
  :config
  (setq mmm-global-mode 'maybe)

  (dolist (langsets '(("script" . ((coffee . coffee-mode)
                                   (es6    . js2-mode)))
                      ("style"  . ((stylus . stylus-mode)
                                   (less   . less-css-mode)
                                   (scss   . scss-mode)))))
    (let ((tag (car langsets)))
      (dolist (pair (cdr langsets))
        (let* ((lang       (car pair))
               (submode    (cdr pair))
               (class-name (make-symbol (format "vueify-%s-%s" tag lang)))
               (front      (format "<%s lang=\"%s\">" tag lang))
               (back       (format "</%s>" tag)))
          (mmm-add-classes
           `((,class-name
              :submode ,submode
              :front ,front
              :back ,back)))
         ;(mmm-add-mode-ext-class nil "\\.vue?\\'" class-name)
          (mmm-add-mode-ext-class nil "\\.vue?\\'" class-name)))))

  (add-to-list 'auto-mode-alist '("\\.vue?\\'" . web-mode))
  (add-to-list 'auto-mode-alist '("\\.we?\\'" . web-mode)))

#+END_SRC
** Error checking

[[http://www.flycheck.org/en/latest/][Flycheck]] is awesome.

#+BEGIN_SRC emacs-lisp
(use-package flycheck
  :ensure t
  :diminish flycheck-mode
  :defer 2
  :general 
    (general-leader-key
            "en" '(flycheck-next-error :which-key "next error")
            "ep" '(flycheck-previous-error :which-key "previous error")
            "el" '(flycheck-list-errors :which-key "list errors"))
  :config
   ;; disable jshint since we prefer eslint checking
  (setq-default flycheck-disabled-checkers
                (append flycheck-disabled-checkers
                        '(javascript-jshint)))
  ;; use eslint with web-mode for jsx files
  (flycheck-add-mode 'javascript-eslint 'web-mode)

  ;; customize flycheck temp file prefix
  (setq-default flycheck-temp-prefix ".flycheck")

  ;; disable json-jsonlist checking for json files
  (setq-default flycheck-disabled-checkers
                (append flycheck-disabled-checkers
                        '(json-jsonlist)))
  (global-flycheck-mode))
#+END_SRC
** Auto completion

[[http://company-mode.github.io][Company mode]] standing for "complete any" is an auto-completion framework with a lot of third part packages and backends. Although I usually trigger manual completion, this is useful to have sometimes. This is a huge definition. Also, this is the one of the functionality I bind to =C-c= and not =M-m=.

#+BEGIN_SRC emacs-lisp
(use-package company
  :ensure t
  :defer t
  :commands (company-mode
             company-complete
             company-complete-common
             company-complete-common-or-cycle
             company-files
             company-dabbrev
             company-ispell
             company-c-headers
             company-jedi
             company-tern
             company-web-html
             company-auctex)
  :init
  (global-company-mode)
  (setq company-minimum-prefix-length 2
        company-require-match 0
        company-selection-wrap-around t
        company-dabbrev-downcase nil
        company-tooltip-limit 20                      ; bigger popup window
        company-tooltip-align-annotations 't          ; align annotations to the right tooltip border
        company-idle-delay .4                         ; decrease delay before autocompletion popup shows
        company-begin-commands '(self-insert-command)) ; start autocompletion only after typing
  (eval-after-load 'company
    '(add-to-list 'company-backends '(company-files
                                      company-capf)))
  :bind (("M-t"   . company-complete)
        ;("C-c f" . company-files)
        ;("C-c a" . company-dabbrev)
        ;("C-c d" . company-ispell)
         :map company-active-map
         ("C-n"    . company-select-next)
         ("C-p"    . company-select-previous)
         ([return] . company-complete-selection)
         ("C-w"    . backward-kill-word)
         ("C-c"    . company-abort)
         ("C-c"    . company-search-abort))
  :diminish (company-mode . "œÇ"))
#+END_SRC

;; HTML completion
;; [[https://github.com/osv/company-web][company-web]]

#+BEGIN_SRC emacs-lisp
(use-package company-web
  :ensure t
  :defer t
  :init
  (with-eval-after-load 'company
    (add-to-list 'company-backends 'company-web-html)))

#+END_SRC

;; Tern for JS

#+BEGIN_SRC emacs-lisp
(use-package company-tern
  :ensure t
  :defer t
  :init
  (setq company-tern-property-marker "")
  (setq company-tern-meta-as-single-line t)
  (with-eval-after-load 'company
    (add-to-list 'company-backends 'company-tern)))

;; Enable JavaScript completion between <script>...</script> etc.
;; https://github.com/osv/company-web
(defadvice company-tern (before web-mode-set-up-ac-sources activate)
  "Set `tern-mode' based on current language before running company-tern."
  (message "advice")
  (if (equal major-mode 'web-mode)
      (let ((web-mode-cur-language
             (web-mode-language-at-pos)))
        (if (or (string= web-mode-cur-language "javascript")
                (string= web-mode-cur-language "jsx")
                )
            (unless tern-mode (tern-mode))
          (if tern-mode (tern-mode -1))))))
#+END_SRC
** smartparens
#+BEGIN_SRC emacs-lisp
 (use-package smartparens
   :ensure t
   :diminish smartparens-mode
   :init
   (progn
     (require 'smartparens-config)
     (defun sp-pair-on-newline (id action context)
       "Put trailing pair on newline and return to point."
       (save-excursion
         (newline)
         (indent-according-to-mode)))
 
     (defun sp-pair-on-newline-and-indent (id action context)
       "Open a new brace or bracket expression, with relevant newlines and indent. "
       (sp-pair-on-newline id action context)
       (indent-according-to-mode))
 
     (sp-pair "{" nil :post-handlers
              '(:add ((lambda (id action context)
                        (sp-pair-on-newline-and-indent id action context)) "RET")))
     (sp-pair "[" nil :post-handlers
              '(:add ((lambda (id action context)
                        (sp-pair-on-newline-and-indent id action context)) "RET")))
 
     (sp-local-pair '(markdown-mode gfm-mode) "*" "*"
                    :unless '(sp-in-string-p)
                    :actions '(insert wrap))
 
     (smartparens-global-mode t)
     (setq sp-highlight-pair-overlay nil)
))

#+END_SRC
** Document
** Code Folding
#+BEGIN_SRC emacs-lisp

#+END_SRC
** Jump to Definition
* Org-mode
  #+BEGIN_SRC emacs-lisp
    ;(org-babel-load-file (concat emacs-base-dir "org-mode.org"))
    (org-babel-load-file (concat emacs-base-dir "gtd.org"))
    (setq org-file-apps org-file-apps-defaults-macosx)
    (setq org-src-tab-acts-natively t)
    (use-package htmlize :ensure t)
    ; rsync
    (defun rsync-org-fold ()
      (interactive)
      (save-window-excursion
        (async-shell-command "~/tools/script/rsync_gtd.sh &")))
    ;(run-at-time 0 10 'rsync-org-fold)
  #+END_SRC
** org-download

[[https://github.com/abo-abo/org-download][This extension]] facilitates moving images from point A to point B.

#+BEGIN_SRC emacs-lisp
(use-package org-download
  :ensure t
  :init 
  (setq-default org-download-image-dir "./img")
  (setq-default org-download-heading-lvl nil)
  :general
  (general-leader-key "ody" 'org-download-yank
                      "ods" 'org-download-screenshot)
  :config
  (org-download-enable))
#+END_SRC
** key bindings
#+BEGIN_SRC emacs-lisp
  (general-leader-key 
   "oa" 'org-agenda
   "ob" 'org-iswitchb
   "oc" 'org-capture)
   
#+END_SRC
* Version control
** Magit

[[https://magit.vc][The best interface to Git ever]]. Enough said.

#+BEGIN_SRC emacs-lisp
(use-package magit
  :ensure t
  :commands magit-status magit-blame
  :init
  (defadvice magit-status (around magit-fullscreen activate)
    (window-configuration-to-register :magit-fullscreen)
    ad-do-it
    (delete-other-windows))
  :config
  (setq magit-branch-arguments nil
        ;; use ido to look for branches
        magit-completing-read-function 'magit-ido-completing-read
        ;; don't put "origin-" in front of new branch names by default
        magit-default-tracking-name-function 'magit-default-tracking-name-branch-only
        magit-push-always-verify nil
        ;; Get rid of the previous advice to go into fullscreen
        magit-restore-window-configuration t)
  :general 
    (general-leader-key
            "vgs" 'magit-status
            "vgb" 'magit-blame
            ))
#+END_SRC
** Highlight diffs

[[https://github.com/dgutov/diff-hl][Highlight git diffs on the fly]].

#+BEGIN_SRC emacs-lisp
(use-package diff-hl
  :ensure t
  :commands (global-diff-hl-mode
             diff-hl-mode
             diff-hl-next-hunk
             diff-hl-previous-hunk
             diff-hl-mark-hunk
             diff-hl-diff-goto-hunk
             diff-hl-revert-hunk)
  :general 
    (general-leader-key
            "v]" 'diff-hl-next-hunk
            "v[" 'diff-hl-previous-hunk
            "vm" 'diff-hl-mark-hunk
            "vh" 'diff-hl-diff-goto-hunk
            "vH" 'diff-hl-revert-hunk)
  :config
  (global-diff-hl-mode)
  (diff-hl-flydiff-mode)
  (diff-hl-margin-mode)
  (diff-hl-dired-mode))
#+END_SRC
** Git time machine

The ability to move to past versions of the current file, [[https://github.com/pidu/git-timemachine][like a time machine]].

#+BEGIN_SRC emacs-lisp
(use-package git-timemachine
  :ensure t
  :commands (git-timemachine-toggle
             git-timemachine-switch-branch)
  :general 
    (general-leader-key
            "vgl" 'git-timemachine-toggle
            "vgL" 'git-timemachine-switch-branch
            ))
#+END_SRC
** Browse remote files

[[https://github.com/rmuslimov/browse-at-remote][browse-at-remote]] is a very handy package to view the file/region on the actual Github/Gitlab/Bitbucket page.

#+BEGIN_SRC emacs-lisp
(use-package browse-at-remote
  :ensure t
  :general 
    (general-leader-key
            "vr" 'browse-at-remote))
#+END_SRC
** =ediff=

[[https://www.gnu.org/software/emacs/manual/html_node/ediff/][Ediff mode]] is a UNIX patching tool and my version controlling package uses this to help resolve merge conflicts and having some better defaults will be useful for this.

#+BEGIN_SRC emacs-lisp
(setq ediff-window-setup-function 'ediff-setup-windows-plain
      ediff-split-window-function 'split-window-horizontally)
#+END_SRC

* Integration
** Console
** Operating System
*** Add a package to set the correct path

Sometimes when opening the Mac Emacs.app via GUI, by clicking the button, it doesn't load all the proper utilities from the OS. This package fixes that.

#+BEGIN_SRC emacs-lisp
(use-package exec-path-from-shell
  :ensure t
  :demand t
  :init
  (setq exec-path-from-shell-check-startup-files nil)
  :config
  ;; (exec-path-from-shell-copy-env "PYTHONPATH")
  (when (memq window-system '(mac ns x))
    (exec-path-from-shell-initialize)))
#+END_SRC

** Search
*** wgrep

Writable grep/ack/ag/pt buffer and apply the changes to files.

#+BEGIN_SRC emacs-lisp
(use-package wgrep
  :ensure t
  :config
  (setq wgrep-enable-key "r"))

#+END_SRC
** Reveal
#+BEGIN_SRC emacs-lisp
  (use-package ox-reveal
    :ensure t
    :init
      (setq org-reveal-root "file:///Users/eshion/emacs.d/lib/reveal.js/")
      ;(setq org-reveal-root "http://cdn.bootcss.com/reveal.js/3.3.0/")
      (setq org-reveal-hlevel 2)
    :config (use-package ox-reveal :ensure t))
#+END_SRC
** Dictionary
[[https://github.com/xuchunyang/youdao-dictionary.el][youdao-dictionary]]
#+BEGIN_SRC emacs-lisp
(use-package youdao-dictionary
  :ensure t
  :init
  (setq url-automatic-caching t)
  :general 
  (general-leader-key
          "xyS" '(youdao-dictionary-search-at-point :which-key "youdao dictionary")
          "xys" '(youdao-dictionary-search-at-point+ :which-key "youdao dictionary popup")))
#+END_SRC

** Calendar
[[https://github.com/kiwanami/emacs-calfw][calfw]] - A calendar framework for Emacs
#+BEGIN_SRC emacs-lisp
(use-package calfw
  :ensure t
  :general 
  (general-leader-key
          "acc" '(my/open-calendar :which-key "open calendar")
          "acb" '(cfw:open-calendar-buffer :which-key "open calendar buffer")
          "aco" '(cfw:open-org-calendar :which-key "open org calendar")
          "aci" '(lambda () (interactive) (cfw:open-ical-calendar "https://calendar.google.com/calendar/ical/en.china%23holiday%40group.v.calendar.google.com/public/basic.ics") :which-key "open google calendar"))
  :init
  (setq cfw:org-overwrite-default-keybinding t)
  :config
  (require 'calfw-cal)
  (require 'calfw-org)
  (require 'calfw-ical)
  (defun my/open-calendar ()
    (interactive)
    (cfw:open-calendar-buffer
     :contents-sources
     (list
      ;(cfw:howm-create-source "Blue")  ; howm source
      ;(cfw:cal-create-source  "Orange") ; diary source
      (cfw:ical-create-source "lunar" "https://raw.githubusercontent.com/infinet/lunar-calendar/master/chinese_lunar_prev_year_next_year.ics" "IndianRed") ; google calendar ICS
      (cfw:ical-create-source "gcal" "https://calendar.google.com/calendar/ical/zh-cn.china%23holiday%40group.v.calendar.google.com/public/basic.ics" "Orange") ; diary source
      (cfw:ical-create-source "Holidays in Armenia" "https://calendar.google.com/calendar/ical/zh-cn.usa%23holiday%40group.v.calendar.google.com/public/basic.ics" "Blue") ; diary source
      (cfw:org-create-source "Green")  ; orgmode source
      ;(cfw:ical-create-source "Moon" "~/moon.ics" "Gray")  ; ICS source1
      )))
)
#+END_SRC

Chinese calendar

ÂÜúÂéÜÂπ¥‰ªΩ‰ª• 60 Âπ¥‰∏∫‰∏Ä‰∏™Âë®ÊúüÔºåÊåâÂÖ¨ÂÖÉÂâç 2637 Âπ¥ÁÆóËµ∑ÁöÑËØùÔºåÂàô 1993 Âπ¥Â§Ñ‰∫éÁ¨¨ 78 ‰∏™Âë®Êúü‰∏≠ÁöÑÁ¨¨ 10 Âπ¥„ÄÇ

http://www.crystalinks.com/calendarchina.html
https://en.wikipedia.org/wiki/Chinese_calendar


you can use something like:

%%(my/diary-chinese-anniversary 10 11 1983) Someone's %d%s Birthday

#+BEGIN_SRC emacs-lisp
(defun my/diary-chinese-anniversary (lunar-month lunar-day &optional year mark)
  (if year
      (let* ((d-date (diary-make-date lunar-month lunar-day year))
             (a-date (calendar-absolute-from-gregorian d-date))
             (c-date (calendar-chinese-from-absolute a-date))
             (cycle (car c-date))
             (yy (cadr c-date))
             (y (+ (* 100 cycle) yy)))
        (diary-chinese-anniversary lunar-month lunar-day y mark))
    (diary-chinese-anniversary lunar-month lunar-day year mark)))
#+END_SRC
** cal-china-x
#+BEGIN_SRC emacs-lisp
(use-package cal-china-x
  :ensure t
  :init
    (setq mark-holidays-in-calendar t)
  :config
    (setq cal-china-x-important-holidays cal-china-x-chinese-holidays)
    (setq calendar-holidays cal-china-x-important-holidays))
#+END_SRC

** markdown-mode

[[https://github.com/jrblevin/markdown-mode][markdown-mode]] is a major mode for editing Markdown-formatted text.

#+BEGIN_SRC emacs-lisp
(use-package markdown-mode
  :ensure t
  :commands (markdown-mode gfm-mode)
  :mode (("README\\.md\\'" . gfm-mode)
         ("\\.md\\'" . markdown-mode)
         ("\\.markdown\\'" . markdown-mode))
  :init (setq markdown-command "multimarkdown"))
#+END_SRC
** elfeed

[[https://github.com/skeeto/elfeed][elfeed]] is an extensible web feed reader for Emacs, supporting both Atom and RSS.

#+BEGIN_SRC emacs-lisp :tangle no
(use-package elfeed
  :ensure t
  :config
  (setq elfeed-feeds
        "http://pragmaticemacs.com/feed/"))
#+END_SRC
* Internet
** Browser
** Mail
** gnus
#+BEGIN_SRC emacs-lisp
(defun my-gnus-group-list-subscribed-groups ()
  "List all subscribed groups with or without un-read messages"
  (interactive)
  (gnus-group-list-all-groups 5)
  )

(add-hook 'gnus-group-mode-hook
          ;; list all the subscribed groups even they contain zero un-read messages
          (lambda () (local-set-key "o" 'my-gnus-group-list-subscribed-groups ))
          )

(setq-default
  gnus-summary-line-format "%U%R%z %(%&user-date;  %-15,15f  %B%s%)\n"
  gnus-user-date-format-alist '((t . "%Y-%m-%d %H:%M"))
  gnus-summary-thread-gathering-function 'gnus-gather-threads-by-references
  gnus-sum-thread-tree-false-root ""
  gnus-sum-thread-tree-indent " "
  gnus-sum-thread-tree-leaf-with-other "‚îú‚ñ∫ "
  gnus-sum-thread-tree-root ""
  gnus-sum-thread-tree-single-leaf "‚ï∞‚ñ∫ "
  gnus-sum-thread-tree-vertical "‚îÇ")
(setq gnus-thread-sort-functions
      '(
        (not gnus-thread-sort-by-date)
        (not gnus-thread-sort-by-number)
        ))

;(setq message-send-mail-function 'smtpmail-send-it
;      smtpmail-starttls-credentials '(("smtp.gmail.com" 587 nil nil))
;      smtpmail-auth-credentials "~/.authinfo.gpg"
;      smtpmail-default-smtp-server "smtp.gmail.com"
;      smtpmail-smtp-server "smtp.gmail.com"
;      smtpmail-smtp-service 587
;      smtpmail-local-domain "localhost")


;; Fetch only part of the article if we can.  I saw this in someone
;; else's .gnus
(setq gnus-read-active-file 'some)

;; Tree view for groups.  I like the organisational feel this has.
;(add-hook 'gnus-group-mode-hook 'gnus-topic-mode)

;; Threads!  I hate reading un-threaded email -- especially mailing
;; lists.  This helps a ton!
(setq gnus-summary-thread-gathering-function
      'gnus-gather-threads-by-subject)

;; Also, I prefer to see only the top level message.  If a message has
;; several replies or is part of a thread, only show the first
;; message.  'gnus-thread-ignore-subject' will ignore the subject and
;; look at 'In-Reply-To:' and 'References:' headers.
(setq gnus-thread-hide-subtree t)
(setq gnus-thread-ignore-subject t)

;(setq mm-text-html-renderer 'eww)

;stop ask me "how many articles from" and
;show-me-all-my-mail-all-ways.
;(setq gnus-large-newsgroup 'nil)

(defun message-select-forwarded-email-tags ()
  "select the <#mml-or-what-ever> tags in message-mode"
  (interactive)
  (let (start rlt)
    (when (search-forward "<#")
      (setq start (point))
      (push-mark (point) t t)
      (goto-char (point-max))
      (search-backward ">")
      (forward-char)
      (setq rlt t))
    rlt))

(defun message-copy-select-forwarded-email-tags ()
  "copy the <#mml-or-what-ever> tags in message-mode"
  (interactive)
  (save-excursion
    (cond
     ((message-select-forwarded-email-tags)
      (copy-region-as-kill (region-beginning) (region-end))
      (message "forwarded email tags copied!"))
     (t (message "NO forwarded email tags found!"))
     )
    ))

#+END_SRC

Use Hydra to avoid remembering key bindings

#+begin_src emacs-lisp
(eval-after-load 'gnus-group
  '(progn
     (defhydra hydra-gnus-group (:color blue)
       "Do?"
       ("a" gnus-group-list-active "REMOTE groups A A")
       ("l" gnus-group-list-all-groups "LOCAL groups L")
       ("c" gnus-topic-catchup-articles "Read all c")
       ("G" gnus-group-make-nnir-group "Search server G G")
       ("g" gnus-group-get-new-news "Refresh g")
       ("s" gnus-group-enter-server-mode "Servers")
       ("m" gnus-group-new-mail "Compose m OR C-x m")
       ("#" gnus-topic-mark-topic "mark #")
       ("q" nil "cancel"))
     ;; y is not used by default
     (define-key gnus-group-mode-map "y" 'hydra-gnus-group/body)))

;; gnus-summary-mode
(eval-after-load 'gnus-sum
  '(progn
     (defhydra hydra-gnus-summary (:color blue)
       "Do?"
       ("s" gnus-summary-show-thread "Show thread")
       ("h" gnus-summary-hide-thread "Hide thread")
       ("n" gnus-summary-insert-new-articles "Refresh / N")
       ("f" gnus-summary-mail-forward "Forward C-c C-f")
       ("!" gnus-summary-tick-article-forward "Mail -> disk !")
       ("p" gnus-summary-put-mark-as-read "Mail <- disk")
       ("c" gnus-summary-catchup-and-exit "Read all c")
       ("e" gnus-summary-resend-message-edit "Resend S D e")
       ("R" gnus-summary-reply-with-original "Reply with original R")
       ("r" gnus-summary-reply "Reply r")
       ("W" gnus-summary-wide-reply-with-original "Reply all with original S W")
       ("w" gnus-summary-wide-reply "Reply all S w")
       ("#" gnus-topic-mark-topic "mark #")
       ("q" nil "cancel"))
     ;; y is not used by default
     (define-key gnus-summary-mode-map "y" 'hydra-gnus-summary/body)))

;; gnus-article-mode
(eval-after-load 'gnus-art
  '(progn
     (defhydra hydra-gnus-article (:color blue)
       "Do?"
       ("f" gnus-summary-mail-forward "Forward")
       ("R" gnus-article-reply-with-original "Reply with original R")
       ("r" gnus-article-reply "Reply r")
       ("W" gnus-article-wide-reply-with-original "Reply all with original S W")
       ("o" gnus-mime-save-part "Save attachment at point o")
       ("w" gnus-article-wide-reply "Reply all S w")
       ("q" nil "cancel"))
     ;; y is not used by default
     (define-key gnus-article-mode-map "y" 'hydra-gnus-article/body)))

(eval-after-load 'message
  '(progn
     (defhydra hydra-message (:color blue)
       "Do?"
       ("ca" mml-attach-file "Attach C-c C-a")
       ("cc" message-send-and-exit "Send C-c C-c")
       ("q" nil "cancel"))
     (global-set-key (kbd "C-c C-y") 'hydra-message/body)))
#+end_src
** bbdb
#+BEGIN_SRC emacs-lisp :tangle no
(use-package bbdb
  :config

  (use-package gnus
    :ensure nil)

  (use-package message
    :ensure nil)

  (use-package bbdb-gnus
    :ensure bbdb
    :config
    (defun eh-bbdb-insinuate-gnus ()
      "BBDB setting for gnus, See `bbdb-insinuate-gnus' for details."
      (define-key gnus-summary-mode-map ":" 'bbdb-mua-display-sender)
      (define-key gnus-article-mode-map ":" 'bbdb-mua-display-sender)
      (define-key gnus-summary-mode-map ";" 'bbdb-mua-edit-field)
      (define-key gnus-article-mode-map ";" 'bbdb-mua-edit-field))

    (add-hook 'gnus-startup-hook 'eh-bbdb-insinuate-gnus))

;  (use-package bbdb-vcard)
;  (use-package bbdb-csv-import)

;  (use-package bbdb-android
;    :config
;    (defun eh-bbdb-keybinding ()
;      (bbdb-handy-keybinding-setup)
;      (define-key bbdb-mode-map "c" 'eh-bbdb-create)
;      (define-key bbdb-mode-map "M" 'bbdb-merge-records)
;      (define-key bbdb-mode-map (kbd "x e") 'bbdb-android-export)
;      (define-key bbdb-mode-map (kbd "x i") 'bbdb-android-import)
;      (define-key bbdb-mode-map (kbd "x r") 'bbdb-android-import-from-radicale))
;    (add-hook 'bbdb-mode-hook 'eh-bbdb-keybinding))

;  (use-package bbdb-handy
;    :config
;    (define-key message-mode-map "\C-cb" 'bbdb-handy)
;    (define-key message-mode-map "\t" 'bbdb-handy-message-tab))

  (setq bbdb-file "~/contacts/contacts.bbdb"
        bbdb-phone-style nil
        bbdb-pop-up-window-size 0.3
        bbdb-mua-pop-up-window-size 1.0
        bbdb-mua-update-interactive-p '(query . create)  ;; Invoking bbdb interactively
        bbdb-message-all-addresses t
        bbdb-mua-summary-mark nil
        bbdb-completion-list t
        bbdb-complete-mail-allow-cycling t
        bbdb-layout 'multi-line
        bbdb-pop-up-layout 'multi-line
        bbdb-mua-pop-up nil
        bbdb-default-country "China"
        bbdb-dial-function 'bbdb-android-dia-with-adb)

  (setq bbdb-vcard-name-imported-priority '(formated-name first-last bbdb-vcard-generate-bbdb-name)
        bbdb-vcard-skip-on-import '("^X-GSM-" "^X-RADICALE-" "^X-CONTACTSYNC-" "^PRODID" "^UID")
        bbdb-vcard-import-translation-table '(("CELL\\|CAR" . "cell")
                                              ("WORK\\|pref" . "work")
                                              ("DOM\\|HOME" . "home")))

  ;; initialization
  ;; (bbdb-initialize 'gnus 'message)
  ;; (bbdb-mua-auto-update-init 'gnus 'message)
  (bbdb-initialize)

  ;; Push email to message-mode
  (defun eh-bbdb-create ()
    (interactive)
    (let ((name (bbdb-read-string "ËÅîÁ≥ª‰∫∫ÂêçÁß∞: "))
          (mail (bbdb-split 'mail (bbdb-read-string "ÁîµÂ≠êÈÇÆ‰ª∂: ")))
          (phone (list (vector "work" (bbdb-read-string "ÁîµËØùÂè∑Á†Å: ")))))
      (bbdb-create-internal name nil nil nil mail phone)
      (bbdb name))))
#+END_SRC

** IRC
** Chat
** Social Network
** Web Feed
* DevOps
** shell-pop
[[https://github.com/kyagi/shell-pop-el][shell-pop.el]] helps you to use shell easily on Emacs. Only one key action to work.

#+BEGIN_SRC emacs-lisp
(use-package shell-pop
  :ensure t
  :bind (("C-t" . shell-pop))
  :config
  (setq shell-pop-shell-type (quote ("ansi-term" "*ansi-term*" (lambda nil (ansi-term shell-pop-term-shell)))))
  (setq shell-pop-term-shell "/usr/local/bin/zsh")
  ;; need to do this manually or not picked up by `shell-pop'
  (shell-pop--set-shell-type 'shell-pop-shell-type shell-pop-shell-type))
#+END_SRC
** persistent-scratch
[[https://github.com/Fanael/persistent-scratch][persistent-scratch]]  is an Emacs package that preserves the state of scratch buffers accross Emacs sessions by saving the state to and restoring it from a file.

#+BEGIN_SRC emacs-lisp
;; persistent-scratch
(use-package persistent-scratch
  :ensure t
  :config
  (persistent-scratch-setup-default))
#+END_SRC
* Package Management
** Package Manager
** Package Configuration
** Package Updates
* Appearance
** Diminish minor modes from the mode line

Now that we have made sure we have installed use-package, we will make sure another nice package to change the [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Mode-Line-Variables.html][mode-line minor mode list]]. For this, we can use use-package itself and also go ahead and diminish some built-in minor modes.

#+BEGIN_SRC emacs-lisp
(use-package diminish
  :ensure t
  :demand t
  :diminish (visual-line-mode . "œâ")
  :diminish hs-minor-mode
  :diminish abbrev-mode
  :diminish auto-fill-function
  :diminish subword-mode)
#+END_SRC

However, some built-in minor modes are notorious and don't seem to work with the above method. Let's diminish them using functions one by one.

*** Diminish =org-indent= mode

I like to enable the [[http://orgmode.org/manual/Clean-view.html][org-indent mode]] for a clean view in Org mode and this doesn't seem to get diminish the usual way. We define a function and a add a hook to achieve this.

#+BEGIN_SRC emacs-lisp
(defun sk/diminish-org-indent ()
  (interactive)
  (diminish 'org-indent-mode ""))
(add-hook 'org-indent-mode-hook 'sk/diminish-org-indent)
#+END_SRC

*** Diminish =auto-revert= mode

[[https://www.gnu.org/software/emacs/manual/html_node/emacs/Reverting.html][auto-revert mode]] is useful when Emacs auto-saves your file and you want to load the backup.

#+BEGIN_SRC emacs-lisp
(defun sk/diminish-auto-revert ()
  (interactive)
  (diminish 'auto-revert-mode ""))
(add-hook 'auto-revert-mode-hook 'sk/diminish-auto-revert)
#+END_SRC

*** Diminish =eldoc= mode

Eldoc mode is a mode to display documentation for languages in Emacs

#+BEGIN_SRC emacs-lisp
(defun sk/diminish-eldoc ()
  (interactive)
  (diminish 'eldoc-mode ""))
(add-hook 'eldoc-mode-hook 'sk/diminish-eldoc)
#+END_SRC

*** Diminish =subword= mode

=subword-mode= is described [[*Move%20correctly%20over%20camelCased%20words][here]].

#+BEGIN_SRC emacs-lisp
(defun sk/diminish-subword ()
  (interactive)
  (diminish 'subword-mode ""))
(add-hook 'subword-mode-hook 'sk/diminish-subword)
#+END_SRC
** adjust-opacity
#+BEGIN_SRC emacs-lisp
(defun my--set-transparency (inc)
  "Increase or decrease the selected frame transparency"
  (let* ((alpha (frame-parameter (selected-frame) 'alpha))
         (next-alpha (cond ((not alpha) 100)
                           ((> (- alpha inc) 100) 100)
                           ((< (- alpha inc) 0) 0)
                           (t (- alpha inc)))))
    (set-frame-parameter (selected-frame) 'alpha next-alpha)))

(defhydra hydra-transparency (:columns 3)
  "
ALPHA : [ %(frame-parameter nil 'alpha) ]
"
  ("j" (lambda () (interactive) (my--set-transparency +1)) "+ opacity")
  ("k" (lambda () (interactive) (my--set-transparency -1)) "- opacity")
  ("=" (lambda () (interactive) (modify-frame-parameters nil `((alpha . 100)))) "reset"))

(general-leader-key "zo" '(hydra-transparency/body :which-key "adjust opacity"))
#+END_SRC

** indent-guide
#+BEGIN_SRC emacs-lisp
(use-package indent-guide
  :ensure t
  :diminish indent-guide-mode
  :config 
    (indent-guide-global-mode))
#+END_SRC
* Theme
#+BEGIN_SRC emacs-lisp
(use-package moe-theme
  :ensure t
  :config 
  (load-theme 'majapahit-light t))
#+END_SRC
* Multimedia
* Fun
** Weather

And while we are it, why not go ahead and [[https://github.com/bcbcarl/emacs-wttrin][get some weather status too]].

#+BEGIN_SRC emacs-lisp
(use-package wttrin
  :ensure t
  :commands (wttrin)
  :init
  (setq wttrin-default-cities '("Shenzhen")))
#+END_SRC

* Key bindings
** which key group describe
#+BEGIN_SRC emacs-lisp
(general-leader-key 
 "a" '(:ignore t :which-key "applications")
 "B" '(:ignore t :which-key "global-buffers")
 "b" '(:ignore t :which-key "buffers")
 "c" '(:ignore t :which-key "compile/comments")
 "e" '(:ignore t :which-key "errors")
 "f" '(:ignore t :which-key "files")
 "fC" '(:ignore t :which-key "files/convert")
 "fe" '(:ignore t :which-key "emacs")
 "fv" '(:ignore t :which-key "variables")
 "h" '(:ignore t :which-key "help")
 "hd" '(:ignore t :which-key "help-describe")
 "i" '(:ignore t :which-key "insertion")
 "j" '(:ignore t :which-key "jump/join/split")
 "k" '(:ignore t :which-key "lisp")
 "l" '(:ignore t :which-key "layer/workspace")
 "n" '(:ignore t :which-key "narrow/numbers")
 "o" '(:ignore t :which-key "org")
 "p" '(:ignore t :which-key "projects")
 "q" '(:ignore t :which-key "quit")
 "r" '(:ignore t :which-key "registers/rings/resume")
 "s" '(:ignore t :which-key "search/symbol")
 "sa" '(:ignore t :which-key "ag")
 "sg" '(:ignore t :which-key "grep")
 "sk" '(:ignore t :which-key "ack")
 "st" '(:ignore t :which-key "pt")
 "T" '(:ignore t :which-key "UI toggles/themes")
 "t" '(:ignore t :which-key "toggles")
 "tC" '(:ignore t :which-key "colors")
 "tE" '(:ignore t :which-key "editing-styles")
 "th" '(:ignore t :which-key "highlight")
 "tm" '(:ignore t :which-key "modeline")
 "v" '(:ignore t :which-key "version-control")
 "vg" '(:ignore t :which-key "magit")
 "w" '(:ignore t :which-key "windows")
 "wp" '(:ignore t :which-key "popup")
 "x" '(:ignore t :which-key "text")
 "xa" '(:ignore t :which-key "align")
 "xd" '(:ignore t :which-key "delete")
 "xj" '(:ignore t :which-key "justification")
 "xl" '(:ignore t :which-key "lines")
 "xr" '(:ignore t :which-key "regular expressions")
 "xt" '(:ignore t :which-key "transpos")
 "xw" '(:ignore t :which-key "words")
 "xy" '(:ignore t :which-key "youdu-translate")
 "z" '(:ignore t :which-key "zoom")
 "" '(:ignore t :which-key "leader"))
#+END_SRC
** global
#+BEGIN_SRC emacs-lisp
;  (general-leader-key 
;   "SPC" (general-simulate-keys "M-x" t "M-x" M-x)
;   )
#+END_SRC
** applications
#+BEGIN_SRC emacs-lisp
  (general-leader-key 
   "ad" 'dired
   "ag" 'gnus
   "ap" 'proced
   "al" 'list-processces
   "au" 'undo-tree-visualize
   "aw" '(wttrin :which-key "Weather")
   "an" '(neotree-dir "~/develop/git/" :which-key "NeoTreeDir"))
#+END_SRC
** buffers
#+BEGIN_SRC emacs-lisp
  (general-leader-key 
   ;"bn" 'next-buffer
   ;"bp" 'previous-buffer
   "bw" 'read-only-mode
   "bc" 'create-new-buffer
   "bk" 'kill-default-buffer
   "bK" 'kill-all-buffers
   )
#+END_SRC
** compile/comments
#+BEGIN_SRC emacs-lisp
  (general-leader-key 
   "cC" 'compile
   "ch" 'hide/show-comments-toggle
   "ck" 'kill-compilation
   "cr" 'recompile
   )
#+END_SRC
** files
#+BEGIN_SRC emacs-lisp
  (general-leader-key 
   "fb" 'bookmark-jump
   "fc" 'copy-file
   "ff" 'find-file
   "fg" 'rgrep
   "fj" 'dired-jump
   "fl" 'find-file-literally
   "fS" 'evil-write-all
   "fs" 'save-buffer
   "fr" 'rename-current-buffer-file
   "fD" 'delete-current-buffer-file
   )
#+END_SRC
*** files/convert
 #+BEGIN_SRC emacs-lisp :tangle no
 (general-leader-key 
    "fd" 'unix2dos
    "fu" 'dos2unix
    )
 #+END_SRC
*** emacs
 #+BEGIN_SRC emacs-lisp :tangle no
   (general-leader-key 
    "f" '()
    )
 #+END_SRC
*** variables
 #+BEGIN_SRC emacs-lisp :tangle no
   (general-leader-key 
    "f" '()
    )
 #+END_SRC
** help
#+BEGIN_SRC emacs-lisp
  (general-leader-key 
  "hn" 'view-emacs-news
  "hw" 'which-key-show-top-level
   )
#+END_SRC
*** help-describe
 #+BEGIN_SRC emacs-lisp
 (general-leader-key 
    "hb" 'describe-bindings
    "hc" 'describe-char
    "hf" 'describe-function
    "hK" 'describe-keymap
    "hk" 'describe-key
    "hp" 'describe-package
    "ht" 'describe-theme
    "hv" 'describe-variable
    )
 #+END_SRC
** insertion
#+BEGIN_SRC emacs-lisp :tangle no
#+END_SRC
** jump/join/split
#+BEGIN_SRC emacs-lisp
  (general-leader-key 
  "jD" 'dired-jump-other-window
  "jd" 'dired-jump
  "jf" 'find-function
  "jI" 'lambda
  "ji" 'counsel-imenu
  "jn" 'sp-newline
  "jo" 'open-line
  "jq" 'dumb-jump-quick-look
  "js" 'sp-split-sexp
  "jv" 'find-variable
   )
#+END_SRC
** narrow/numbers
#+BEGIN_SRC emacs-lisp
  (general-leader-key 
  "nf" 'narrow-to-defun
  "np" 'narrow-to-page
  "nr" 'narrow-to-region
  "nw" 'widen
   )
#+END_SRC
** search/symbol
#+BEGIN_SRC emacs-lisp
  (general-leader-key 
   "sb" 'swiper-all
   "ss" 'swiper
   )
#+END_SRC
*** ag
 #+BEGIN_SRC emacs-lisp :tangle no
 (general-leader-key 
    "sa" '()
    )
 #+END_SRC
*** grep
 #+BEGIN_SRC emacs-lisp :tangle no
   (general-leader-key 
    "sg" '()
    )
 #+END_SRC
*** ack
 #+BEGIN_SRC emacs-lisp :tangle no
   (general-leader-key 
    "sk" '()
    )
 #+END_SRC
*** pt
 #+BEGIN_SRC emacs-lisp :tangle no
   (general-leader-key 
    "st" '()
    )
 #+END_SRC
** toggles
#+BEGIN_SRC emacs-lisp
  (general-leader-key 
  "tn" '(linum-mode :which-key "line number")
  "tv" 'visual-line-mode
  "ta" 'company-mode
  "ti" 'indent-guide-global-mode
  "to" 'global-origami-mode
  "tk" 'which-key-mode
  "ts" 'smartparens-strict-mode
  "te" 'emmet-mode
  "tp" 'emmet-preview-mode
  "tc" 'global-flycheck-mode
  "tt" '(toggle-truncate-lines :which-key "truncate lines")
   )
#+END_SRC
*** colors
 #+BEGIN_SRC emacs-lisp
 (general-leader-key 
    "tCd" 'rainbow-delimiters-mode
    "tCp" 'highlight-parentheses-mode
    )
 #+END_SRC
*** editing-styles
 #+BEGIN_SRC emacs-lisp :tangle no
   (general-leader-key 
    "tE" '()
    )
 #+END_SRC
*** highlight
 #+BEGIN_SRC emacs-lisp :tangle no
   (general-leader-key 
    "th" '()
    )
 #+END_SRC
*** modeline
 #+BEGIN_SRC emacs-lisp :tangle no
   (general-leader-key 
    "tm" '()
    )
 #+END_SRC
** windows
#+BEGIN_SRC emacs-lisp
  (general-leader-key 
   "w-" 'sk/split-below-and-move
   "w|" 'sk/split-right-and-move
   "w=" 'balance-windows
   "wF" 'make-frame
   "wf" 'follow-mode
   "wH" 'evil-window-move-far-left
   "wh" 'evil-window-left
   "wJ" 'evil-window-move-very-bottom
   "wj" 'evil-window-down
   "wK" 'evil-window-move-very-top
   "wk" 'evil-window-up
   "wL" 'evil-window-move-far-right
   "wl" 'evil-window-right
   "w<down>" 'evil-window-down
   "w<left>" 'evil-window-left
   "w<right>" 'evil-window-right
   "w<up>" 'evil-window-up
   "w<S-down>" 'evil-window-move-very-bottom
   "w<S-left>" 'evil-window-move-far-left
   "w<S-right>" 'evil-window-move-far-right
   "w<S-up>" 'evil-window-move-very-top
   "wo" 'other-frame
   "wS" 'split-window-below-and-focus
   "ws" 'split-window-below
   "wU" 'winner-redo
   "wu" 'winner-undo
   "wV" 'split-window-right-and-focus
   "wv" 'split-window-right
   "ww" 'other-window
   )
#+END_SRC
** text
#+BEGIN_SRC emacs-lisp
  (general-leader-key 
   "x<TAB>" 'indent-rigidly
   "xc" 'count-region
   "xU" 'upcase-region
   "xu" 'downcase-region
   )
#+END_SRC
*** align
 #+BEGIN_SRC emacs-lisp
 (general-leader-key 
    "xaa" 'align
    "xac" 'align-current
    )
 #+END_SRC
*** delete
 #+BEGIN_SRC emacs-lisp
 (general-leader-key 
    "xdw" 'delete-whitespace-rectangle
    )
 #+END_SRC
*** justification
 #+BEGIN_SRC emacs-lisp
 (general-leader-key 
    "xjc" 'set-justification-center
    "xjf" 'set-justification-full
    "xjl" 'set-justification-left
    "xjn" 'set-justification-none
    "xjr" 'set-justification-right
    )
 #+END_SRC
*** transpos
 #+BEGIN_SRC emacs-lisp
 (general-leader-key 
    "xtc" 'transpos-chars
    "xtl" 'transpos-lines
    "xtw" 'transpos-words
    )
 #+END_SRC
*** words
 #+BEGIN_SRC emacs-lisp
 (general-leader-key 
    "xwd" 'defind-word-at-point
    )
 #+END_SRC
* Load Customize
#+BEGIN_SRC emacs-lisp
(load custom-file 'noerror)
#+END_SRC
